<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Creative Hand Particle System</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: white; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI Panel */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; width: 280px;
            background: rgba(20, 20, 30, 0.7); backdrop-filter: blur(10px);
            border-radius: 12px; padding: 20px; z-index: 10;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: opacity 0.3s;
        }
        .ui-group { margin-bottom: 15px; }
        .ui-label { font-size: 12px; color: #aaa; margin-bottom: 5px; display: block; letter-spacing: 1px; text-transform: uppercase; }
        
        button {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: white; padding: 8px 12px; border-radius: 6px; cursor: pointer;
            margin: 2px; font-size: 12px; transition: background 0.2s;
        }
        button:hover { background: rgba(255,255,255,0.25); }
        button.active { background: #00d2ff; color: #000; border-color: #00d2ff; }
        
        input[type="range"] { width: 100%; accent-color: #00d2ff; }
        input[type="color"] { border: none; width: 100%; height: 30px; cursor: pointer; background: none; }

        /* Status & Camera Preview */
        #status-bar {
            position: absolute; bottom: 20px; left: 20px; z-index: 10;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px;
            font-family: monospace; font-size: 12px; pointer-events: none;
        }
        #cam-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px;
            background: #222; border-radius: 8px; z-index: 10;
            transform: scaleX(-1); /* Mirror */
            border: 2px solid rgba(255,255,255,0.1);
            object-fit: cover;
        }
        
        /* Permission overlay */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center;
        }
        .hidden { display: none !important; }
        h1 { margin-bottom: 10px; font-weight: 300; letter-spacing: 2px; }
        #loading-text { color: #00d2ff; animation: pulse 1.5s infinite; margin-top: 20px;}
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
    </style>

    <script src="lib/three.min.js" onerror="this.onerror=null; this.src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'"></script>
    <script src="lib/camera_utils.js" onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js'"></script>
    <script src="lib/control_utils.js" onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js'"></script>
    <script src="lib/hands.js" onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js'"></script>
</head>
<body>

    <div id="overlay">
        <h1>CREATIVE PARTICLE HANDS</h1>
        <p>Allow camera access to control the particles.</p>
        <button id="start-btn" style="font-size: 16px; padding: 10px 30px; margin-top: 20px;">START EXPERIENCE</button>
        <div id="loading-text" class="hidden">Initializing AI & WebGL...</div>
        <div id="error-msg" style="color: #ff4444; margin-top: 20px;" class="hidden"></div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-panel" class="hidden">
        <div class="ui-group">
            <span class="ui-label">Shapes</span>
            <div id="shape-buttons">
                </div>
        </div>
        <div class="ui-group">
            <span class="ui-label">Particle Color</span>
            <input type="color" id="color-picker" value="#00d2ff">
        </div>
        <div class="ui-group">
            <span class="ui-label">Gesture Sensitivity</span>
            <input type="range" id="sensitivity-slider" min="0.1" max="2.0" step="0.1" value="1.0">
        </div>
        <button id="reset-btn" style="width: 100%">Reset Physics</button>
    </div>

    <div id="status-bar" class="hidden">
        <div>SYS: <span id="sys-status">Ready</span></div>
        <div>HANDS: <span id="hand-count">0</span></div>
        <div>EVENT: <span id="last-event">-</span></div>
    </div>

    <video id="cam-preview" class="hidden" playsinline></video>

    <script>
        // Import performance utilities
        const PerformanceOptimizer = window.PerformanceOptimizer || {
            detectPerformanceLevel: () => 'medium',
            getOptimizedSettings: () => ({ particleCount: 15000 })
        };

        /**
         * =========================================================================
         * SECTION 1: PERFORMANCE MONITORING & ADJUSTMENT
         * =========================================================================
         */
        const PERFORMANCE = {
            fps: 0,
            lastFrameTime: 0,
            frameCount: 0,
            lastFpsUpdate: 0,
            performanceLevel: 'unknown',
            targetFPS: 60,
            adaptiveMode: true,
            
            init: function() {
                this.performanceLevel = PerformanceOptimizer.detectPerformanceLevel();
                console.log(`Performance level detected: ${this.performanceLevel}`);
                
                // Set target FPS based on performance level
                if (this.performanceLevel === 'low') {
                    this.targetFPS = 30;
                } else if (this.performanceLevel === 'medium') {
                    this.targetFPS = 45;
                } else {
                    this.targetFPS = 60;
                }
                
                this.lastFrameTime = performance.now();
                this.updateStatus();
            },
            
            update: function(currentTime) {
                this.frameCount++;
                
                // Update FPS every second
                if (currentTime - this.lastFpsUpdate >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                    this.updateStatus();
                    
                    // Adaptive adjustment if FPS is too low
                    if (this.adaptiveMode && this.fps < this.targetFPS * 0.7) {
                        this.adjustQuality();
                    }
                }
            },
            
            updateStatus: function() {
                const statusEl = document.getElementById('sys-status');
                if (statusEl) {
                    statusEl.innerHTML = `${this.fps}FPS | ${this.performanceLevel.toUpperCase()} | ${STATE.particleCount.toLocaleString()} particles`;
                }
            },
            
            adjustQuality: function() {
                console.log(`Performance warning: ${this.fps}FPS, adjusting quality...`);
                
                // Reduce particle count if possible
                if (STATE.particleCount > 5000) {
                    const newCount = Math.max(5000, Math.floor(STATE.particleCount * 0.7));
                    console.log(`Reducing particles from ${STATE.particleCount} to ${newCount}`);
                    this.adjustParticleCount(newCount);
                }
                
                // Show warning to user
                this.showPerformanceWarning();
            },
            
            adjustParticleCount: function(newCount) {
                if (newCount === STATE.particleCount) return;
                
                // Create new arrays with adjusted size
                const oldPositions = geometry.attributes.position.array;
                const oldTargets = targets;
                const oldVelocities = velocities;
                
                // Create new arrays
                const newPositions = new Float32Array(newCount * 3);
                const newTargets = new Float32Array(newCount * 3);
                const newVelocities = new Float32Array(newCount * 3);
                
                // Copy existing data (or generate new if expanding)
                const copyCount = Math.min(STATE.particleCount, newCount);
                for (let i = 0; i < copyCount * 3; i++) {
                    newPositions[i] = oldPositions[i];
                    newTargets[i] = oldTargets[i];
                    newVelocities[i] = oldVelocities[i];
                }
                
                // If expanding, fill remaining with random positions
                if (newCount > STATE.particleCount) {
                    for (let i = STATE.particleCount * 3; i < newCount * 3; i++) {
                        newPositions[i] = (Math.random() - 0.5) * 200;
                        newTargets[i] = newPositions[i];
                        newVelocities[i] = 0;
                    }
                }
                
                // Update geometry
                geometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
                
                // Update global references
                positions = newPositions;
                targets = newTargets;
                velocities = newVelocities;
                STATE.particleCount = newCount;
                
                // Regenerate current shape
                generateShape(STATE.currentShapeIndex);
                
                console.log(`Particle count adjusted to ${newCount}`);
                this.updateStatus();
            },
            
            showPerformanceWarning: function() {
                // Create or update warning element
                let warningEl = document.getElementById('performance-warning');
                if (!warningEl) {
                    warningEl = document.createElement('div');
                    warningEl.id = 'performance-warning';
                    warningEl.style.cssText = `
                        position: absolute;
                        top: 60px;
                        right: 20px;
                        background: rgba(255, 100, 0, 0.9);
                        color: white;
                        padding: 10px 15px;
                        border-radius: 8px;
                        font-size: 12px;
                        z-index: 100;
                        max-width: 250px;
                        backdrop-filter: blur(5px);
                        border: 1px solid rgba(255, 255, 255, 0.2);
                    `;
                    document.body.appendChild(warningEl);
                }
                
                warningEl.innerHTML = `
                    <strong>⚠️ Performance Notice</strong><br>
                    System adjusted for smoother experience.<br>
                    Particles: ${STATE.particleCount.toLocaleString()} | FPS: ${this.fps}
                `;
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    if (warningEl) warningEl.style.opacity = '0';
                }, 5000);
            }
        };

        /**
         * =========================================================================
         * SECTION 2: GAME RULES / INTERACTION CONFIGURATION
         * =========================================================================
         */
        const GAME_RULES = {
            // Configuration
            sensitivity: 1.0,
            pinchThreshold: 0.05, // Distance between thumb and index
            openThreshold: 0.8,   // Normalized openness

            // Event Mapping: Event Name -> Action Function
            'PINCH_LEFT':   (ctx) => ctx.actions.switchShape(-1), // Prev Shape
            'PINCH_RIGHT':  (ctx) => ctx.actions.switchShape(1),  // Next Shape
            'OPEN_BOTH':    (ctx) => ctx.actions.explode(2.0),    // Strong Expand
            'CLOSE_BOTH':   (ctx) => ctx.actions.implode(2.0),    // Strong Contract
            'OPEN_ONE':     (ctx) => ctx.actions.explode(0.8),    // Gentle Expand
            'CLOSE_ONE':    (ctx) => ctx.actions.implode(0.8),    // Gentle Contract
            'NO_HANDS':     (ctx) => ctx.actions.idle(),          // Drift
            'MOVE_HANDS':   (ctx) => ctx.actions.attract(ctx.hands) // Follow hands
        };

        /**
         * =========================================================================
         * SECTION 3: CORE SYSTEM (Three.js & Particle Logic)
         * =========================================================================
         */
        
        // --- Global State ---
        const STATE = {
            width: window.innerWidth,
            height: window.innerHeight,
            particleCount: 15000, // Start with reasonable default
            currentShapeIndex: 0,
            color: new THREE.Color(0x00d2ff),
            handsDetected: 0,
            handData: [], // Stores smoothed landmarks
            lastPinchTime: 0
        };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        // Fog for depth
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, STATE.width / STATE.height, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(STATE.width, STATE.height);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- Particles ---
        // We use BufferGeometry for performance with raw TypedArrays
        const geometry = new THREE.BufferGeometry();
        
        // Attributes (will be initialized after performance detection)
        let positions, targets, velocities;
        
        function initParticleSystem(particleCount) {
            STATE.particleCount = particleCount;
            
            positions = new Float32Array(particleCount * 3);
            targets = new Float32Array(particleCount * 3); // Destination shape
            velocities = new Float32Array(particleCount * 3); // Physics velocity
            
            // Init Random Positions
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 200;
                targets[i] = positions[i];
                velocities[i] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setDrawRange(0, particleCount);
        }

        // Initialize with optimal particle count based on performance level
        const perfSettings = PerformanceOptimizer.getOptimizedSettings('game4');
        const initialParticleCount = perfSettings?.particleCount ||
            (PERFORMANCE.performanceLevel === 'low' ? 8000 :
             PERFORMANCE.performanceLevel === 'medium' ? 15000 : 25000);
        
        initParticleSystem(initialParticleCount);

        // Create a soft circle texture programmatically
        const getSprite = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        };

        const material = new THREE.PointsMaterial({
            size: 0.4,
            map: getSprite(),
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            color: STATE.color
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Generators ---
        // Mathematical functions to populate 'targets' array
        const SHAPES = [
            { name: 'Heart', gen: (i) => {
                const t = Math.random() * Math.PI * 2;
                // Distribute points inside volume roughly
                const r = Math.sqrt(Math.random()) * 15; 
                // Heart formula variant
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                // Extrude z slightly
                const z = (Math.random() - 0.5) * 10;
                return [x * (r/15), y * (r/15), z];
            }},
            { name: 'Saturn', gen: (i) => {
                const isRing = Math.random() > 0.4;
                if (isRing) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 20 + Math.random() * 8;
                    return [Math.cos(angle) * r, (Math.random()-0.5)*2, Math.sin(angle) * r];
                } else {
                    // Sphere
                    const u = Math.random(); const v = Math.random();
                    const theta = 2 * Math.PI * u;
                    const phi = Math.acos(2 * v - 1);
                    const r = 12 * Math.cbrt(Math.random()); 
                    return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
                }
            }},
            { name: 'Flower', gen: (i) => {
                const u = Math.random() * Math.PI * 2; // angle
                const v = Math.random() * Math.PI;
                const r = 15 + 5 * Math.sin(5 * u) * Math.sin(5 * v);
                return [r * Math.sin(v) * Math.cos(u), r * Math.sin(v) * Math.sin(u), (Math.random()-0.5)*5];
            }},
            { name: 'Fireworks', gen: (i) => {
                // Just random sphere burst
                const u = Math.random(); const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r = 40 * Math.cbrt(Math.random());
                return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
            }},
            { name: 'Spiral', gen: (i) => {
                const t = i * 0.05;
                const r = t * 0.02;
                return [r * Math.cos(t), t * 0.5 - 30, r * Math.sin(t)];
            }}
        ];

        function generateShape(shapeIndex) {
            const generator = SHAPES[shapeIndex].gen;
            // Use requestAnimationFrame to avoid blocking main thread for large particle counts
            const batchSize = 1000;
            let processed = 0;
            
            function processBatch() {
                const end = Math.min(processed + batchSize, STATE.particleCount);
                for (let i = processed; i < end; i++) {
                    const [x, y, z] = generator(i);
                    const idx = i * 3;
                    targets[idx] = x;
                    targets[idx + 1] = y;
                    targets[idx + 2] = z;
                }
                processed = end;
                
                if (processed < STATE.particleCount) {
                    requestAnimationFrame(processBatch);
                } else {
                    updateUIButtons();
                }
            }
            
            processBatch();
        }

        // --- Interaction Logic (Actions) ---
        // These are called by the Event Mapper
        const actions = {
            currentForce: 0,
            
            switchShape: (dir) => {
                const now = Date.now();
                if (now - STATE.lastPinchTime < 1000) return; // Debounce
                STATE.lastPinchTime = now;
                
                STATE.currentShapeIndex = (STATE.currentShapeIndex + dir + SHAPES.length) % SHAPES.length;
                generateShape(STATE.currentShapeIndex);
                document.getElementById('last-event').innerText = "SWITCH SHAPE";
                
                // Visual Flash
                material.color.setHex(0xffffff);
                setTimeout(() => material.color.set(STATE.color), 300);
            },

            explode: (intensity) => {
                actions.currentForce = 0.5 * intensity * GAME_RULES.sensitivity;
                document.getElementById('last-event').innerText = "EXPAND";
            },

            implode: (intensity) => {
                actions.currentForce = -0.5 * intensity * GAME_RULES.sensitivity;
                document.getElementById('last-event').innerText = "CONTRACT";
            },

            attract: (hands) => {
                // Logic handled in physics loop using hand positions
                document.getElementById('last-event').innerText = "TRACKING";
            },

            idle: () => {
                actions.currentForce *= 0.95; // Decay force
                document.getElementById('last-event').innerText = "IDLE";
            }
        };

        // --- Physics Loop ---
        function updateParticles() {
            const positions = geometry.attributes.position.array;
            
            // Mouse/Hand interaction vector
            // If hands are detected, we calculate center of hands
            let centerX = 0, centerY = 0, centerZ = 0;
            if (STATE.handsDetected > 0) {
                // Map hand coordinates (0..1) to World Coordinates (-Aspect..Aspect)
                // Roughly mapping screen space to z=0 plane in 3D
                STATE.handData.forEach(h => {
                    centerX += (h.x - 0.5) * 50; 
                    centerY += -(h.y - 0.5) * 40; // Invert Y
                });
                centerX /= STATE.handsDetected;
                centerY /= STATE.handsDetected;
            }

            for (let i = 0; i < STATE.particleCount; i++) {
                const idx = i * 3;
                
                // 1. Seek Target (Shape formation)
                const tx = targets[idx];
                const ty = targets[idx + 1];
                const tz = targets[idx + 2];

                const px = positions[idx];
                const py = positions[idx + 1];
                const pz = positions[idx + 2];

                // Spring force towards target
                const ax = (tx - px) * 0.02; // Stiffness
                const ay = (ty - py) * 0.02;
                const az = (tz - pz) * 0.02;

                velocities[idx]     += ax;
                velocities[idx + 1] += ay;
                velocities[idx + 2] += az;

                // 2. Hand Interaction (Explode/Implode/MouseFollow)
                // Add noise/turbulence
                velocities[idx] += (Math.random() - 0.5) * 0.05; 
                velocities[idx+1] += (Math.random() - 0.5) * 0.05; 

                if (actions.currentForce !== 0) {
                    // Vector from center (0,0,0) or hand center to particle
                    const dx = px - centerX;
                    const dy = py - centerY;
                    const dz = pz - centerZ;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    const dist = Math.sqrt(distSq);
                    
                    if (dist > 0.1) {
                        // F = force / dist
                        const f = actions.currentForce * 50 / (dist + 1);
                        velocities[idx]     += (dx / dist) * f;
                        velocities[idx + 1] += (dy / dist) * f;
                        velocities[idx + 2] += (dz / dist) * f;
                    }
                }

                // 3. Apply Velocity & Damping
                positions[idx]     += velocities[idx];
                positions[idx + 1] += velocities[idx + 1];
                positions[idx + 2] += velocities[idx + 2];

                velocities[idx]     *= 0.92; // Friction
                velocities[idx + 1] *= 0.92;
                velocities[idx + 2] *= 0.92;
            }

            geometry.attributes.position.needsUpdate = true;
            
            // Rotate entire system slowly
            particles.rotation.y += 0.002;
        }

        // --- Render Loop with Frame Rate Control ---
        let lastRenderTime = 0;
        let frameId = null;
        
        function animate(currentTime) {
            frameId = requestAnimationFrame(animate);
            
            // Frame rate control
            const timeSinceLastRender = currentTime - lastRenderTime;
            const targetFrameTime = 1000 / PERFORMANCE.targetFPS;
            
            if (timeSinceLastRender < targetFrameTime) {
                return; // Skip frame to maintain target FPS
            }
            
            lastRenderTime = currentTime;
            
            // Update performance monitoring
            PERFORMANCE.update(currentTime);
            
            // Update particles and render
            updateParticles();
            renderer.render(scene, camera);
        }
        
        function stopAnimation() {
            if (frameId) {
                cancelAnimationFrame(frameId);
                frameId = null;
            }
        }

        /**
         * =========================================================================
         * SECTION 3: COMPUTER VISION (MediaPipe)
         * =========================================================================
         */
        
        const videoElement = document.getElementById('cam-preview');
        let handsResults = null;

        function onResults(results) {
            handsResults = results;
            processGestures();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Camera setup with promise-based error handling
        const startCamera = () => {
            return new Promise((resolve, reject) => {
                // Check if camera is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    reject(new Error('Camera API not supported in this browser.'));
                    return;
                }
                
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        try {
                            await hands.send({image: videoElement});
                        } catch (e) {
                            console.warn('Hands processing error:', e);
                        }
                    },
                    width: 320,
                    height: 240
                });
                
                camera.start()
                .then(() => {
                    document.getElementById('overlay').classList.add('hidden');
                    document.getElementById('ui-panel').classList.remove('hidden');
                    document.getElementById('status-bar').classList.remove('hidden');
                    document.getElementById('cam-preview').classList.remove('hidden');
                    document.getElementById('sys-status').innerText = "Running";
                    resolve();
                })
                .catch(err => {
                    console.error('Camera start failed:', err);
                    
                    // Provide specific error messages
                    let errorMsg = "Camera Access Denied.";
                    if (err.name === 'NotAllowedError') {
                        errorMsg = "Camera permission denied. Please allow camera access in your browser settings.";
                    } else if (err.name === 'NotFoundError') {
                        errorMsg = "No camera found. Please connect a camera and try again.";
                    } else if (err.name === 'NotReadableError') {
                        errorMsg = "Camera is in use by another application.";
                    }
                    
                    reject(new Error(errorMsg));
                });
            });
        };

        // --- Gesture Analysis & Event Emission ---
        // Smoothing variables (EMA)
        let smoothedOpenness = [0, 0]; 
        let smoothedPinch = [1, 1]; 

        function distance(a, b) {
            return Math.hypot(a.x - b.x, a.y - b.y);
        }

        function processGestures() {
            if (!handsResults || !handsResults.multiHandLandmarks) return;

            const landmarks = handsResults.multiHandLandmarks;
            STATE.handsDetected = landmarks.length;
            document.getElementById('hand-count').innerText = STATE.handsDetected;

            STATE.handData = []; // Reset for physics usage

            if (STATE.handsDetected === 0) {
                GAME_RULES['NO_HANDS']({ actions });
                return;
            }

            let isOpenL = false, isOpenR = false;
            let isPinchL = false, isPinchR = false;

            for (let i = 0; i < landmarks.length; i++) {
                const hand = landmarks[i];
                const handedness = handsResults.multiHandedness[i].label; // Left or Right

                // 1. Store center pos for physics attraction
                STATE.handData.push({x: hand[9].x, y: hand[9].y}); // Landmark 9 is middle finger mcp (roughly palm center)

                // 2. Calculate Openness
                // Sum distances of tips (4,8,12,16,20) from wrist (0)
                let totalDist = 0;
                [4, 8, 12, 16, 20].forEach(tip => {
                    totalDist += distance(hand[0], hand[tip]);
                });
                // Normalize roughly (0.8 to 2.5 is typical range sum, divide to get 0..1)
                let openness = Math.min(1, Math.max(0, (totalDist - 0.8) / 1.5));
                
                // EMA Smoothing
                smoothedOpenness[i] = smoothedOpenness[i] * 0.7 + openness * 0.3;

                // 3. Calculate Pinch (Thumb Tip 4 to Index Tip 8)
                let pinchDist = distance(hand[4], hand[8]);
                smoothedPinch[i] = smoothedPinch[i] * 0.7 + pinchDist * 0.3;

                // 4. Determine Boolean States
                const isOpen = smoothedOpenness[i] > GAME_RULES.openThreshold;
                const isPinch = smoothedPinch[i] < GAME_RULES.pinchThreshold;

                if (i === 0) { isOpenL = isOpen; isPinchL = isPinch; }
                else { isOpenR = isOpen; isPinchR = isPinch; }
                
                // Trigger Individual Pinch Events immediately
                if (isPinch) {
                    const eventName = (handedness === 'Left') ? 'PINCH_LEFT' : 'PINCH_RIGHT'; // Note: Mirroring might swap these visually
                    // We just map index 0 to Left logic and 1 to Right logic for simplicity in this demo
                    if(i===0 && isPinch) GAME_RULES['PINCH_LEFT']({ actions });
                    if(i===1 && isPinch) GAME_RULES['PINCH_RIGHT']({ actions });
                }
            }

            // 5. Fire Combined Events
            if (STATE.handsDetected === 2) {
                if (isOpenL && isOpenR) GAME_RULES['OPEN_BOTH']({ actions });
                else if (!isOpenL && !isOpenR) GAME_RULES['CLOSE_BOTH']({ actions });
                else GAME_RULES['MOVE_HANDS']({ actions });
            } else if (STATE.handsDetected === 1) {
                if (isOpenL) GAME_RULES['OPEN_ONE']({ actions });
                else GAME_RULES['CLOSE_ONE']({ actions });
                GAME_RULES['MOVE_HANDS']({ actions }); // Also track position
            }
        }

        /**
         * =========================================================================
         * SECTION 4: UI & EVENTS
         * =========================================================================
         */
        
        // Start Button with improved error handling
        document.getElementById('start-btn').addEventListener('click', async () => {
            document.getElementById('start-btn').classList.add('hidden');
            document.getElementById('loading-text').classList.remove('hidden');
            
            try {
                // Initialize performance monitoring
                PERFORMANCE.init();
                
                // Check if Three.js loaded
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js failed to load. Please check your internet connection.');
                }
                
                // Check WebGL support
                if (!renderer.capabilities.isWebGL2 && !renderer.capabilities.isWebGL1) {
                    throw new Error('WebGL is not supported in your browser. Please try a modern browser.');
                }
                
                // Start camera and animation
                await startCamera();
                generateShape(0); // Init Shape
                animate(performance.now()); // Start Loop with performance timing
                
            } catch (error) {
                console.error('Startup error:', error);
                document.getElementById('loading-text').classList.add('hidden');
                document.getElementById('error-msg').classList.remove('hidden');
                document.getElementById('error-msg').innerHTML = `
                    <strong>Startup Failed</strong><br>
                    ${error.message}<br>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 15px;">Retry</button>
                `;
            }
        });

        // Shape Buttons
        const shapeContainer = document.getElementById('shape-buttons');
        function updateUIButtons() {
            shapeContainer.innerHTML = '';
            SHAPES.forEach((s, i) => {
                const btn = document.createElement('button');
                btn.innerText = s.name;
                if (i === STATE.currentShapeIndex) btn.classList.add('active');
                btn.onclick = () => {
                    STATE.currentShapeIndex = i;
                    generateShape(i);
                };
                shapeContainer.appendChild(btn);
            });
        }

        // Color Picker
        document.getElementById('color-picker').addEventListener('input', (e) => {
            STATE.color.set(e.target.value);
            material.color.set(STATE.color);
        });

        // Sensitivity
        document.getElementById('sensitivity-slider').addEventListener('input', (e) => {
            GAME_RULES.sensitivity = parseFloat(e.target.value);
        });

        // Reset
        document.getElementById('reset-btn').addEventListener('click', () => {
            for(let i=0; i<STATE.particleCount*3; i++) velocities[i] = 0;
            actions.currentForce = 0;
        });

        // Window Resize with debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                STATE.width = window.innerWidth;
                STATE.height = window.innerHeight;
                camera.aspect = STATE.width / STATE.height;
                camera.updateProjectionMatrix();
                renderer.setSize(STATE.width, STATE.height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
            }, 250);
        });

        // Page visibility handling
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, pause animation to save resources
                stopAnimation();
                document.getElementById('sys-status').innerText = "Paused (Tab Hidden)";
            } else {
                // Page is visible again, resume animation
                if (frameId === null) {
                    lastRenderTime = performance.now();
                    animate(performance.now());
                }
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            stopAnimation();
            if (hands && hands.close) {
                hands.close();
            }
            if (videoElement.srcObject) {
                const tracks = videoElement.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }
        });

        // Add manual performance adjustment button to UI
        const uiPanel = document.getElementById('ui-panel');
        const perfControlGroup = document.createElement('div');
        perfControlGroup.className = 'ui-group';
        perfControlGroup.innerHTML = `
            <span class="ui-label">Performance</span>
            <div style="display: flex; gap: 5px; margin-top: 5px;">
                <button id="perf-low" title="Low (8k particles)">Low</button>
                <button id="perf-medium" title="Medium (15k particles)">Medium</button>
                <button id="perf-high" title="High (25k particles)">High</button>
            </div>
        `;
        uiPanel.insertBefore(perfControlGroup, uiPanel.querySelector('.ui-group:last-child'));

        // Performance control event handlers
        document.getElementById('perf-low').addEventListener('click', () => {
            PERFORMANCE.adjustParticleCount(8000);
            PERFORMANCE.performanceLevel = 'low';
            PERFORMANCE.targetFPS = 30;
            PERFORMANCE.updateStatus();
        });
        
        document.getElementById('perf-medium').addEventListener('click', () => {
            PERFORMANCE.adjustParticleCount(15000);
            PERFORMANCE.performanceLevel = 'medium';
            PERFORMANCE.targetFPS = 45;
            PERFORMANCE.updateStatus();
        });
        
        document.getElementById('perf-high').addEventListener('click', () => {
            PERFORMANCE.adjustParticleCount(25000);
            PERFORMANCE.performanceLevel = 'high';
            PERFORMANCE.targetFPS = 60;
            PERFORMANCE.updateStatus();
        });

    </script>
</body>
</html>