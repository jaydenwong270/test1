<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast - Fixed</title>
    <style>
        :root {
            --bg-gradient: linear-gradient(180deg, #E3F2FD 0%, #90CAF9 100%);
            --text-color: #1565C0;
            --grid-bg: #263238;          
            --cell-empty: #37474F;       
            --accent-gold: #FBC02D;
            --text-blue: #E3F2FD;
            --modal-bg-gradient: linear-gradient(to bottom, #1E88E5 0%, #0D47A1 100%);
            --btn-green-start: #4cd964; 
            --btn-green-end: #28b446;   
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-gradient);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        /* é ‚éƒ¨è³‡è¨Šæ¬„ */
        .top-bar {
            width: 100%;
            max-width: 420px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            position: absolute;
            top: 0;
            z-index: 10;
        }

        /* å¢žå¤§çš‡å† èˆ‡åˆ†æ•¸ */
        .high-score { 
            font-size: 2.2rem; 
            color: var(--accent-gold); 
            font-weight: 800; 
            display: flex; 
            align-items: center; 
            gap: 12px; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.15); 
        }
        
        .icon-btn { 
            font-size: 1.8rem; 
            opacity: 0.8; 
            cursor: pointer; 
            color: var(--text-color);
            transition: transform 0.2s;
        }
        .icon-btn:active { transform: rotate(45deg) scale(0.9); }

        /* ä¸»å®¹å™¨ */
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 420px;
            transform: translateY(-10px); 
        }

        .score-container { text-align: center; margin-bottom: 15px; margin-top: 60px; }
        
        .current-score { 
            font-size: 4.5rem; 
            font-weight: 800; 
            text-shadow: 0 4px 10px rgba(0,0,0,0.1); 
            line-height: 1; 
            color: var(--text-color);
        }

        /* æ£‹ç›¤ */
        #game-board-container {
            position: relative;
            background: var(--grid-bg);
            padding: 8px;
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(21, 101, 192, 0.2), inset 0 2px 5px rgba(255,255,255,0.05);
            margin-bottom: 15px;
        }

        canvas#gridCanvas { display: block; border-radius: 8px; }

        /* åº•éƒ¨æ–¹å¡Š */
        .shapes-area {
            width: 100%;
            height: 110px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
        }

        .shape-preview {
            flex: 1;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas.shape-item {
            transition: transform 0.1s, opacity 0.2s;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
        }

        #drag-proxy {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            display: none;
            filter: drop-shadow(0 25px 25px rgba(0,0,0,0.3));
        }

        /* Game Over */
        #modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--modal-bg-gradient);
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding-bottom: 50px;
        }

        .modal-title {
            font-size: 4rem;
            font-weight: 900;
            color: var(--text-blue);
            margin-bottom: 40px;
            text-shadow: 0 4px 10px rgba(0,0,0,0.2);
            letter-spacing: 1px;
        }

        .modal-label {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 600;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .modal-score-val {
            font-size: 4.5rem;
            font-weight: 800;
            color: #ffffff;
            margin-bottom: 30px;
            text-shadow: 0 3px 8px rgba(0,0,0,0.2);
            line-height: 1;
        }
        
        .modal-best-val { color: var(--accent-gold); }

        .btn-play {
            width: 180px;
            height: 70px;
            background: linear-gradient(to bottom, var(--btn-green-start), var(--btn-green-end));
            border: none;
            border-radius: 35px;
            cursor: pointer;
            box-shadow: 0 6px 0 #1e8e33, 0 15px 20px rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.1s;
            margin-top: 20px;
        }

        .btn-play:active {
            transform: translateY(6px);
            box-shadow: 0 0 0 #1e8e33, 0 5px 10px rgba(0,0,0,0.1);
        }

        .play-icon {
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #ffffff;
            transform: translateX(3px);
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="high-score">ðŸ‘‘ <span id="best-score">0</span></div>
        <div class="icon-btn" onclick="resetGameWithoutSaving()" title="é‡æ–°é–‹å§‹">ðŸ”„</div>
    </div>

    <div class="main-container">
        <div class="score-container">
            <div class="current-score" id="score">0</div>
        </div>

        <div id="game-board-container">
            <canvas id="gridCanvas"></canvas>
        </div>

        <div class="shapes-area" id="shapes-container"></div>
    </div>

    <canvas id="drag-proxy"></canvas>

    <div id="modal-overlay">
        <div class="modal-title">Game Over</div>
        <div class="modal-label">Score</div>
        <div class="modal-score-val" id="final-score">0</div>
        <div class="modal-label">Best Score</div>
        <div class="modal-score-val modal-best-val" id="final-best-score">0</div>
        <button class="btn-play" onclick="restartGame()">
            <div class="play-icon"></div>
        </button>
    </div>

    <script>
        const CONFIG = {
            gridSize: 8,
            gap: 4,
            borderRadius: 6,
            colors: {
                empty: '#37474F',
                shapes: ['#FF3355', '#FFD500', '#29B6F6', '#66BB6A', '#AB47BC', '#FF7043', '#1E88E5']
            }
        };

        const DRAG_OFFSET_Y = 100;

        let grid = []; 
        let score = 0;
        let bestScore = localStorage.getItem('blockBlastBest') || 0;
        let shapes = [];
        let cellSize = 0;

        let isDragging = false;
        let dragShapeIndex = -1;
        let dragStartOffset = { x: 0, y: 0 };

        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const proxyCanvas = document.getElementById('drag-proxy');
        const shapesContainer = document.getElementById('shapes-container');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best-score');
        const modal = document.getElementById('modal-overlay');
        const finalScoreEl = document.getElementById('final-score');
        const finalBestScoreEl = document.getElementById('final-best-score');

        const SHAPES_DB = [
            [[1]], 
            [[1,1]], [[1],[1]], 
            [[1,1,1]], [[1],[1],[1]], 
            [[1,1,1,1]], [[1],[1],[1],[1]], 
            [[1,1,1,1,1]], [[1],[1],[1],[1],[1]],
            [[1,1],[1,1]], 
            [[1,1,1],[1,1,1],[1,1,1]], 
            [[1,1,1],[1,1,1]], [[1,1],[1,1],[1,1]], 
            [[1,1],[1,0]], [[1,1],[0,1]], [[1,0],[1,1]], [[0,1],[1,1]], 
            [[1,0],[1,0],[1,1]], [[0,1],[0,1],[1,1]], [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]], 
            [[1,1],[1,0],[1,0]], [[1,1],[0,1],[0,1]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]], 
            [[0,1,0],[1,1,1]], [[1,1,1],[0,1,0]], [[1,0],[1,1],[1,0]], [[0,1],[1,1],[0,1]], 
            [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]], [[0,1],[1,1],[1,0]]
        ];

        function init() {
            bestEl.innerText = bestScore;
            resizeGame();
            window.addEventListener('resize', () => { resizeGame(); drawGrid(); });
            
            const events = ['mousedown', 'touchstart'];
            events.forEach(evt => window.addEventListener(evt, handleStart, {passive: false}));
            const moveEvents = ['mousemove', 'touchmove'];
            moveEvents.forEach(evt => window.addEventListener(evt, handleMove, {passive: false}));
            const endEvents = ['mouseup', 'touchend'];
            endEvents.forEach(evt => window.addEventListener(evt, handleEnd));

            restartGame();
        }

        function resizeGame() {
            const maxWidth = Math.min(window.innerWidth - 30, 380); 
            canvas.width = maxWidth;
            canvas.height = maxWidth;
            cellSize = (canvas.width - (CONFIG.gap * (CONFIG.gridSize + 1))) / CONFIG.gridSize;
        }

        function resetGameWithoutSaving() {
            if (score > 0 && !confirm('ç¢ºå®šè¦é‡æ–°é–‹å§‹å—Žï¼Ÿç›®å‰çš„é€²åº¦å°‡ä¸æœƒä¿å­˜ã€‚')) {
                return;
            }
            restartGame();
        }

        function restartGame() {
            grid = Array(CONFIG.gridSize).fill().map(() => Array(CONFIG.gridSize).fill(null));
            score = 0;
            updateScore(0);
            modal.style.display = 'none';
            drawGrid();
            spawnShapes();
        }

        // --- ä¿®å¾© Bug çš„æ ¸å¿ƒï¼šé€šç”¨åœ“è§’çŸ©å½¢ç¹ªè£½å‡½æ•¸ ---
        // è¨±å¤šç€è¦½å™¨ä¸æ”¯æ´ ctx.roundRectï¼Œé€™è£¡æ”¹ç”¨åŽŸç”Ÿçš„è·¯å¾‘å¯«æ³•
        function drawRoundedPath(ctx, x, y, size, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + size - r, y);
            ctx.quadraticCurveTo(x + size, y, x + size, y + r);
            ctx.lineTo(x + size, y + size - r);
            ctx.quadraticCurveTo(x + size, y + size, x + size - r, y + size);
            ctx.lineTo(x + r, y + size);
            ctx.quadraticCurveTo(x, y + size, x, y + size - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawGlossyBlock(ctx, x, y, size, color) {
            // ä½¿ç”¨é€šç”¨çš„è·¯å¾‘ç¹ªè£½
            drawRoundedPath(ctx, x, y, size, CONFIG.borderRadius);
            
            // å¡«è‰²
            const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
            gradient.addColorStop(0, adjustColor(color, 30));
            gradient.addColorStop(0.5, color);
            gradient.addColorStop(1, adjustColor(color, -30));
            ctx.fillStyle = gradient;
            ctx.fill();

            // é«˜å…‰
            const shine = ctx.createLinearGradient(x, y, x, y + size);
            shine.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            shine.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
            shine.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = shine;
            ctx.fill();

            // é‚Šæ¡†
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.stroke();
        }

        function adjustColor(color, amount) {
            return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
        }

        function drawEmptyCell(ctx, x, y, size) {
            ctx.fillStyle = CONFIG.colors.empty;
            // ä½¿ç”¨é€šç”¨çš„è·¯å¾‘ç¹ªè£½
            drawRoundedPath(ctx, x, y, size, CONFIG.borderRadius);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        function drawGrid(highlightMatrix = null, highlightRow = -1, highlightCol = -1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for(let r=0; r<CONFIG.gridSize; r++) {
                for(let c=0; c<CONFIG.gridSize; c++) {
                    const x = CONFIG.gap + c * (cellSize + CONFIG.gap);
                    const y = CONFIG.gap + r * (cellSize + CONFIG.gap);
                    const color = grid[r][c];
                    if (color) {
                        drawGlossyBlock(ctx, x, y, cellSize, color);
                    } else {
                        drawEmptyCell(ctx, x, y, cellSize);
                    }
                    if(highlightMatrix && highlightRow !== -1) {
                        const hr = r - highlightRow;
                        const hc = c - highlightCol;
                        if(hr >= 0 && hr < highlightMatrix.length && hc >= 0 && hc < highlightMatrix[0].length && highlightMatrix[hr][hc] === 1) {
                            ctx.globalAlpha = 0.5;
                            drawGlossyBlock(ctx, x, y, cellSize, shapes[dragShapeIndex].color);
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
            }
        }

        function drawShapeToCanvas(targetCanvas, matrix, color, scale = 1) {
            const size = cellSize * scale;
            const gap = CONFIG.gap * scale;
            const rows = matrix.length;
            const cols = matrix[0].length;
            const padding = 4;
            targetCanvas.width = (gap + cols * (size + gap)) + padding * 2;
            targetCanvas.height = (gap + rows * (size + gap)) + padding * 2;
            const tCtx = targetCanvas.getContext('2d');
            tCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(matrix[r][c]) {
                        drawGlossyBlock(tCtx, padding + gap + c * (size + gap), padding + gap + r * (size + gap), size, color);
                    }
                }
            }
        }

        function getEventPos(e) {
            if(e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            else if (e.changedTouches && e.changedTouches.length > 0) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        function handleStart(e) {
            const target = e.target.closest('.shape-item');
            if(!target) return;
            const index = parseInt(target.dataset.index);
            if(shapes[index].used) return;
            e.preventDefault();
            isDragging = true;
            dragShapeIndex = index;
            const pos = getEventPos(e);
            const shape = shapes[index];
            drawShapeToCanvas(proxyCanvas, shape.matrix, shape.color, 1.0);
            proxyCanvas.style.display = 'block';
            const rect = proxyCanvas.getBoundingClientRect();
            dragStartOffset.x = rect.width / 2;
            dragStartOffset.y = rect.height / 2;
            updateProxyPos(pos.x, pos.y);
            target.style.opacity = 0;
        }

        function handleMove(e) {
            if(!isDragging) return;
            e.preventDefault();
            const pos = getEventPos(e);
            updateProxyPos(pos.x, pos.y);
            const gridPos = getGridPosFromProxy();
            if(gridPos && canPlace(shapes[dragShapeIndex].matrix, gridPos.r, gridPos.c)) {
                drawGrid(shapes[dragShapeIndex].matrix, gridPos.r, gridPos.c);
            } else {
                drawGrid();
            }
        }

        function handleEnd(e) {
            if(!isDragging) return;
            const gridPos = getGridPosFromProxy();
            const shape = shapes[dragShapeIndex];
            const originalEl = document.querySelector(`.shape-item[data-index="${dragShapeIndex}"]`);
            if(gridPos && canPlace(shape.matrix, gridPos.r, gridPos.c)) {
                placeShape(shape, gridPos.r, gridPos.c);
                shape.used = true;
                originalEl.parentElement.innerHTML = ''; 
                if(shapes.every(s => s.used)) spawnShapes();
                else checkGameOver();
            } else {
                originalEl.style.opacity = 1;
                drawGrid();
            }
            isDragging = false;
            proxyCanvas.style.display = 'none';
        }

        function updateProxyPos(x, y) {
            proxyCanvas.style.left = (x - dragStartOffset.x) + 'px';
            proxyCanvas.style.top = (y - dragStartOffset.y - DRAG_OFFSET_Y) + 'px';
        }

        function getGridPosFromProxy() {
            const proxyRect = proxyCanvas.getBoundingClientRect();
            const gridRect = canvas.getBoundingClientRect();
            const relativeX = proxyRect.left - gridRect.left;
            const relativeY = proxyRect.top - gridRect.top;
            const scaleX = canvas.width / gridRect.width;
            const scaleY = canvas.height / gridRect.height;
            const canvasX = relativeX * scaleX;
            const canvasY = relativeY * scaleY;
            const col = Math.round((canvasX - CONFIG.gap) / (cellSize + CONFIG.gap));
            const row = Math.round((canvasY - CONFIG.gap) / (cellSize + CONFIG.gap));
            return { r: row, c: col };
        }

        function spawnShapes() {
            shapes = [];
            shapesContainer.innerHTML = '';
            for(let i=0; i<3; i++) {
                const matrix = SHAPES_DB[Math.floor(Math.random() * SHAPES_DB.length)];
                const color = CONFIG.colors.shapes[Math.floor(Math.random() * CONFIG.colors.shapes.length)];
                shapes.push({ matrix, color, used: false });
                const wrapper = document.createElement('div');
                wrapper.className = 'shape-preview';
                const canvasEl = document.createElement('canvas');
                canvasEl.className = 'shape-item';
                canvasEl.dataset.index = i; 
                drawShapeToCanvas(canvasEl, matrix, color, 0.55); 
                wrapper.appendChild(canvasEl);
                shapesContainer.appendChild(wrapper);
            }
            checkGameOver();
        }

        function canPlace(matrix, r, c) {
            for(let i=0; i<matrix.length; i++) {
                for(let j=0; j<matrix[0].length; j++) {
                    if(matrix[i][j] === 1) {
                        const tr = r + i;
                        const tc = c + j;
                        if(tr < 0 || tr >= CONFIG.gridSize || tc < 0 || tc >= CONFIG.gridSize || grid[tr][tc]) return false;
                    }
                }
            }
            return true;
        }

        function placeShape(shape, r, c) {
            let placedCount = 0;
            for(let i=0; i<shape.matrix.length; i++) {
                for(let j=0; j<shape.matrix[0].length; j++) {
                    if(shape.matrix[i][j] === 1) {
                        grid[r + i][c + j] = shape.color;
                        placedCount++;
                    }
                }
            }
            score += placedCount;
            updateScore(score);
            requestAnimationFrame(() => { checkLines(); drawGrid(); });
        }

        function checkLines() {
            let rowsToClear = [], colsToClear = [];
            for(let r=0; r<CONFIG.gridSize; r++) if(grid[r].every(v => v)) rowsToClear.push(r);
            for(let c=0; c<CONFIG.gridSize; c++) if(grid.every(row => row[c])) colsToClear.push(c);
            if(rowsToClear.length === 0 && colsToClear.length === 0) return;
            rowsToClear.forEach(r => grid[r].fill(null));
            colsToClear.forEach(c => { for(let r=0; r<CONFIG.gridSize; r++) grid[r][c] = null; });
            const lines = rowsToClear.length + colsToClear.length;
            const points = lines * 100 * lines; 
            updateScore(score + points);
        }

        function checkGameOver() {
            const remaining = shapes.filter(s => !s.used);
            if(remaining.length === 0) return;
            let canMove = false;
            for(let s of remaining) {
                for(let r=0; r<CONFIG.gridSize; r++) {
                    for(let c=0; c<CONFIG.gridSize; c++) {
                        if(canPlace(s.matrix, r, c)) { canMove = true; break; }
                    }
                    if(canMove) break;
                }
                if(canMove) break;
            }
            if(!canMove) {
                finalScoreEl.innerText = score;
                finalBestScoreEl.innerText = bestScore;
                modal.style.display = 'flex';
            }
        }

        function updateScore(v) {
            score = v;
            scoreEl.innerText = score;
            if(score > bestScore) {
                bestScore = score;
                bestEl.innerText = bestScore;
                localStorage.setItem('blockBlastBest', bestScore);
            }
        }

        init();
    </script>
</body>
</html>