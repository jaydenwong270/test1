<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Blast - Final Fixed</title>
    <style>
        :root {
            /* Ëµ∑ÂßãËÉåÊôØÔºöÈùõËóç (700) */
            --bg-gradient: linear-gradient(180deg, #303F9F 0%, #3949AB 100%);
            --text-color: #FFFFFF;
            --grid-bg: #263238;          
            --cell-empty: #37474F;       
            --accent-gold: #FFD700;
            --text-blue: #E3F2FD;
            --modal-bg-gradient: linear-gradient(to bottom, #1E88E5 0%, #0D47A1 100%);
            --btn-green-start: #4cd964; 
            --btn-green-end: #28b446;   
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000000; 
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .app-wrapper {
            width: 100%;
            max-width: 480px;
            height: 100%;
            background: var(--bg-gradient);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            transition: background 1s ease;
        }

        /* È†ÇÈÉ®Ë≥áË®äÊ¨Ñ */
        .top-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            position: absolute;
            top: 0;
            z-index: 10;
        }

        .high-score { 
            font-size: 2rem; 
            color: var(--accent-gold); 
            font-weight: 800; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            text-shadow: 0 2px 4px rgba(0,0,0,0.3); 
        }
        
        .icon-btn { 
            width: 44px;
            height: 44px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            cursor: pointer; 
            color: #ffffff;
            transition: all 0.2s;
            backdrop-filter: blur(4px);
        }
        
        .icon-btn:active { 
            transform: scale(0.9); 
            background: rgba(255, 255, 255, 0.25);
        }

        /* ‰∏ªÂÆπÂô® */
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; 
            width: 100%;
            height: 100%; 
            padding-top: 60px; 
            padding-bottom: 10px;
        }

        .score-container { 
            text-align: center; 
            margin-bottom: 5px; /* ÂÜçÁ®çÂæÆÊ∏õÂ∞ë‰∏ÄÈªûÈÇäË∑ù */
            flex-shrink: 0; 
            
        }
        
        .current-score { 
            font-size: 4rem; 
            font-weight: 800; 
            text-shadow: 0 4px 10px rgba(0,0,0,0.3); 
            line-height: 1; 
            color: var(--text-color);
        }

        /* Ê£ãÁõ§ */
        #game-board-container {
            position: relative;
            background: var(--grid-bg);
            padding: 4px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4), inset 0 2px 5px rgba(255,255,255,0.05);
            margin: 5px 0; /* Ê∏õÂ∞ë‰∏ä‰∏ãÈÇäË∑ù */
            flex-shrink: 1; 
        }

        canvas#gridCanvas { display: block; border-radius: 8px; }

        /* ‰øÆÊîπÈªû 1: Â∫ïÈÉ®ÊñπÂ°äÂçÄÈ´òÂ∫¶Â¢ûÂä†ÔºåÂÆπÁ¥ç 5 Ê†ºÈï∑Ê¢ù */
        .shapes-area {
            width: 100%;
            height: 140px; /* Âæû 100px Â¢ûÂä†Âà∞ 140px */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            flex-shrink: 0; 
        }

        .shape-preview {
            flex: 1;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas.shape-item {
            transition: transform 0.1s, opacity 0.2s;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        #drag-proxy {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            display: none;
            filter: drop-shadow(0 25px 25px rgba(0,0,0,0.4));
        }

        /* Game Over */
        #modal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--modal-bg-gradient);
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding-bottom: 50px;
        }

        .modal-title {
            font-size: 4rem;
            font-weight: 900;
            color: var(--text-blue);
            margin-bottom: 40px;
            text-shadow: 0 4px 10px rgba(0,0,0,0.3);
            letter-spacing: 1px;
        }

        .modal-label {
            font-size: 1.1rem;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 600;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .modal-score-val {
            font-size: 4.5rem;
            font-weight: 800;
            color: #ffffff;
            margin-bottom: 30px;
            text-shadow: 0 3px 8px rgba(0,0,0,0.3);
            line-height: 1;
        }
        
        .modal-best-val { color: var(--accent-gold); }

        .btn-play {
            width: 180px;
            height: 70px;
            background: linear-gradient(to bottom, var(--btn-green-start), var(--btn-green-end));
            border: none;
            border-radius: 35px;
            cursor: pointer;
            box-shadow: 0 6px 0 #1e8e33, 0 15px 20px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.1s;
            margin-top: 20px;
        }

        .btn-play:active {
            transform: translateY(6px);
            box-shadow: 0 0 0 #1e8e33, 0 5px 10px rgba(0,0,0,0.2);
        }

        .play-icon {
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 18px 0 18px 30px;
            border-color: transparent transparent transparent #ffffff;
            transform: translateX(3px);
        }
    </style>
</head>
<body>

    <div class="app-wrapper" id="appWrapper">
        <div class="top-bar">
            <div class="high-score">üëë <span id="best-score">0</span></div>
            <div class="icon-btn" onclick="resetGameWithoutSaving()" title="ÈáçÊñ∞ÈñãÂßã">
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                    <path d="M3 3v5h5"></path>
                </svg>
            </div>
        </div>

        <div class="main-container">
            <div class="score-container">
                <div class="current-score" id="score">0</div>
            </div>

            <div id="game-board-container">
                <canvas id="gridCanvas"></canvas>
            </div>

            <div class="shapes-area" id="shapes-container"></div>
        </div>

        <div id="modal-overlay">
            <div class="modal-title">Game Over</div>
            <div class="modal-label">Score</div>
            <div class="modal-score-val" id="final-score">0</div>
            <div class="modal-label">Best Score</div>
            <div class="modal-score-val modal-best-val" id="final-best-score">0</div>
            <button class="btn-play" onclick="restartGame()">
                <div class="play-icon"></div>
            </button>
        </div>
    </div>

    <canvas id="drag-proxy"></canvas>

    <script>
        const CONFIG = {
            gridSize: 8,
            gap: 4,
            borderRadius: 6,
            colors: {
                empty: '#37474F',
                shapes: ['#FF3355', '#FFD500', '#29B6F6', '#66BB6A', '#AB47BC', '#FF7043', '#1E88E5']
            }
        };

        const DRAG_OFFSET_Y = 100;

        const BG_GRADIENTS = [
            'linear-gradient(180deg, #303F9F 0%, #3949AB 100%)', // Level 0: ÈùõËóç
            'linear-gradient(180deg, #512DA8 0%, #5E35B1 100%)', // Level 1: Ê∑±Á¥´
            'linear-gradient(180deg, #00796B 0%, #00897B 100%)', // Level 2: ÈùíÁ∂†
            'linear-gradient(180deg, #388E3C 0%, #43A047 100%)', // Level 3: Á∂†Ëâ≤
            'linear-gradient(180deg, #D32F2F 0%, #E53935 100%)', // Level 4: Á¥ÖËâ≤
            'linear-gradient(180deg, #455A64 0%, #546E7A 100%)'  // Level 5: ËóçÁÅ∞
        ];

        let grid = []; 
        let score = 0;
        let bestScore = localStorage.getItem('blockBlastBest') || 0;
        let shapes = [];
        let cellSize = 0;

        let isDragging = false;
        let dragShapeIndex = -1;
        let dragStartOffset = { x: 0, y: 0 };

        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const proxyCanvas = document.getElementById('drag-proxy');
        const shapesContainer = document.getElementById('shapes-container');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best-score');
        const modal = document.getElementById('modal-overlay');
        const finalScoreEl = document.getElementById('final-score');
        const finalBestScoreEl = document.getElementById('final-best-score');
        const appWrapper = document.getElementById('appWrapper');

        const SHAPES_DB = [
            [[1]], 
            [[1,1]], [[1],[1]], 
            [[1,1,1]], [[1],[1],[1]], 
            [[1,1,1,1]], [[1],[1],[1],[1]], 
            [[1,1,1,1,1]], [[1],[1],[1],[1],[1]],
            [[1,1],[1,1]], 
            [[1,1,1],[1,1,1],[1,1,1]], 
            [[1,1,1],[1,1,1]], [[1,1],[1,1],[1,1]], 
            [[1,1],[1,0]], [[1,1],[0,1]], [[1,0],[1,1]], [[0,1],[1,1]], 
            [[1,0],[1,0],[1,1]], [[0,1],[0,1],[1,1]], [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]], 
            [[1,1],[1,0],[1,0]], [[1,1],[0,1],[0,1]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]], 
            [[0,1,0],[1,1,1]], [[1,1,1],[0,1,0]], [[1,0],[1,1],[1,0]], [[0,1],[1,1],[0,1]], 
            [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]], [[0,1],[1,1],[1,0]]
        ];

        function init() {
            bestEl.innerText = bestScore;
            resizeGame();
            window.addEventListener('resize', () => { resizeGame(); drawGrid(); });
            
            const events = ['mousedown', 'touchstart'];
            events.forEach(evt => window.addEventListener(evt, handleStart, {passive: false}));
            const moveEvents = ['mousemove', 'touchmove'];
            moveEvents.forEach(evt => window.addEventListener(evt, handleMove, {passive: false}));
            const endEvents = ['mouseup', 'touchend'];
            endEvents.forEach(evt => window.addEventListener(evt, handleEnd));

            restartGame();
        }

        // --- ‰øÆÊîπÈªû 2: Êõ¥Êñ∞Áï´Èù¢Á∏ÆÊîæÈÇèËºØÔºåÁÇ∫Â∫ïÈÉ®È†êÁïôÊõ¥Â§öÁ©∫Èñì ---
        function resizeGame() {
            // ÂØ¨Â∫¶ÈôêÂà∂ (Â∑¶Âè≥È†êÁïôÈÇäË∑ù)
            const widthLimit = Math.min(window.innerWidth - 30, 440);
            
            // È´òÂ∫¶ÈôêÂà∂ (È†êÁïôÈ†ÇÈÉ® 60 + ÂàÜÊï∏ 80 + Â∫ïÈÉ® 140 + ÈñìË∑ù 60 ~= 340)
            const heightLimit = window.innerHeight - 340; 
            
            // ÂèñÂÖ©ËÄÖËºÉÂ∞èÂÄº
            const size = Math.min(widthLimit, heightLimit);
            
            // Ë®≠ÁΩÆÊúÄÂ∞èÂ∞∫ÂØ∏
            const finalSize = Math.max(size, 260); 

            canvas.width = finalSize;
            canvas.height = finalSize;
            cellSize = (canvas.width - (CONFIG.gap * (CONFIG.gridSize + 1))) / CONFIG.gridSize;
        }

        function resetGameWithoutSaving() {
            if (score > 0 && !confirm('Á¢∫ÂÆöË¶ÅÈáçÊñ∞ÈñãÂßãÂóéÔºüÁõÆÂâçÁöÑÈÄ≤Â∫¶Â∞á‰∏çÊúÉ‰øùÂ≠ò„ÄÇ')) {
                return;
            }
            restartGame();
        }

        function restartGame() {
            grid = Array(CONFIG.gridSize).fill().map(() => Array(CONFIG.gridSize).fill(null));
            score = 0;
            updateScore(0);
            modal.style.display = 'none';
            drawGrid();
            spawnShapes();
        }

        function drawRoundedPath(ctx, x, y, size, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + size - r, y);
            ctx.quadraticCurveTo(x + size, y, x + size, y + r);
            ctx.lineTo(x + size, y + size - r);
            ctx.quadraticCurveTo(x + size, y + size, x + size - r, y + size);
            ctx.lineTo(x + r, y + size);
            ctx.quadraticCurveTo(x, y + size, x, y + size - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawGlossyBlock(ctx, x, y, size, color) {
            drawRoundedPath(ctx, x, y, size, CONFIG.borderRadius);
            
            const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
            gradient.addColorStop(0, adjustColor(color, 30));
            gradient.addColorStop(0.5, color);
            gradient.addColorStop(1, adjustColor(color, -30));
            ctx.fillStyle = gradient;
            ctx.fill();

            const shine = ctx.createLinearGradient(x, y, x, y + size);
            shine.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
            shine.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
            shine.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = shine;
            ctx.fill();

            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            ctx.stroke();
        }

        function adjustColor(color, amount) {
            return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
        }

        function drawEmptyCell(ctx, x, y, size) {
            ctx.fillStyle = CONFIG.colors.empty;
            drawRoundedPath(ctx, x, y, size, CONFIG.borderRadius);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        function drawGrid(highlightMatrix = null, highlightRow = -1, highlightCol = -1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for(let r=0; r<CONFIG.gridSize; r++) {
                for(let c=0; c<CONFIG.gridSize; c++) {
                    const x = CONFIG.gap + c * (cellSize + CONFIG.gap);
                    const y = CONFIG.gap + r * (cellSize + CONFIG.gap);
                    const color = grid[r][c];
                    if (color) {
                        drawGlossyBlock(ctx, x, y, cellSize, color);
                    } else {
                        drawEmptyCell(ctx, x, y, cellSize);
                    }
                    if(highlightMatrix && highlightRow !== -1) {
                        const hr = r - highlightRow;
                        const hc = c - highlightCol;
                        if(hr >= 0 && hr < highlightMatrix.length && hc >= 0 && hc < highlightMatrix[0].length && highlightMatrix[hr][hc] === 1) {
                            ctx.globalAlpha = 0.5;
                            drawGlossyBlock(ctx, x, y, cellSize, shapes[dragShapeIndex].color);
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
            }
        }

        function drawShapeToCanvas(targetCanvas, matrix, color, scale = 1) {
            const size = cellSize * scale;
            const gap = CONFIG.gap * scale;
            const rows = matrix.length;
            const cols = matrix[0].length;
            const padding = 4;
            targetCanvas.width = (gap + cols * (size + gap)) + padding * 2;
            targetCanvas.height = (gap + rows * (size + gap)) + padding * 2;
            const tCtx = targetCanvas.getContext('2d');
            tCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(matrix[r][c]) {
                        drawGlossyBlock(tCtx, padding + gap + c * (size + gap), padding + gap + r * (size + gap), size, color);
                    }
                }
            }
        }

        function getEventPos(e) {
            if(e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            else if (e.changedTouches && e.changedTouches.length > 0) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            return { x: e.clientX, y: e.clientY };
        }

        function handleStart(e) {
            const target = e.target.closest('.shape-item');
            if(!target) return;
            const index = parseInt(target.dataset.index);
            if(shapes[index].used) return;
            e.preventDefault();
            isDragging = true;
            dragShapeIndex = index;
            const pos = getEventPos(e);
            const shape = shapes[index];
            drawShapeToCanvas(proxyCanvas, shape.matrix, shape.color, 1.0);
            proxyCanvas.style.display = 'block';
            const rect = proxyCanvas.getBoundingClientRect();
            dragStartOffset.x = rect.width / 2;
            dragStartOffset.y = rect.height / 2;
            updateProxyPos(pos.x, pos.y);
            target.style.opacity = 0;
        }

        function handleMove(e) {
            if(!isDragging) return;
            e.preventDefault();
            const pos = getEventPos(e);
            updateProxyPos(pos.x, pos.y);
            const gridPos = getGridPosFromProxy();
            if(gridPos && canPlace(shapes[dragShapeIndex].matrix, gridPos.r, gridPos.c)) {
                drawGrid(shapes[dragShapeIndex].matrix, gridPos.r, gridPos.c);
            } else {
                drawGrid();
            }
        }

        function handleEnd(e) {
            if(!isDragging) return;
            const gridPos = getGridPosFromProxy();
            const shape = shapes[dragShapeIndex];
            const originalEl = document.querySelector(`.shape-item[data-index="${dragShapeIndex}"]`);
            if(gridPos && canPlace(shape.matrix, gridPos.r, gridPos.c)) {
                placeShape(shape, gridPos.r, gridPos.c);
                shape.used = true;
                originalEl.parentElement.innerHTML = ''; 
                if(shapes.every(s => s.used)) spawnShapes();
                else checkGameOver();
            } else {
                originalEl.style.opacity = 1;
                drawGrid();
            }
            isDragging = false;
            proxyCanvas.style.display = 'none';
        }

        function updateProxyPos(x, y) {
            proxyCanvas.style.left = (x - dragStartOffset.x) + 'px';
            proxyCanvas.style.top = (y - dragStartOffset.y - DRAG_OFFSET_Y) + 'px';
        }

        function getGridPosFromProxy() {
            const proxyRect = proxyCanvas.getBoundingClientRect();
            const gridRect = canvas.getBoundingClientRect();
            const relativeX = proxyRect.left - gridRect.left;
            const relativeY = proxyRect.top - gridRect.top;
            const scaleX = canvas.width / gridRect.width;
            const scaleY = canvas.height / gridRect.height;
            const canvasX = relativeX * scaleX;
            const canvasY = relativeY * scaleY;
            const col = Math.round((canvasX - CONFIG.gap) / (cellSize + CONFIG.gap));
            const row = Math.round((canvasY - CONFIG.gap) / (cellSize + CONFIG.gap));
            return { r: row, c: col };
        }

        function spawnShapes() {
            shapes = [];
            shapesContainer.innerHTML = '';
            for(let i=0; i<3; i++) {
                const matrix = SHAPES_DB[Math.floor(Math.random() * SHAPES_DB.length)];
                const color = CONFIG.colors.shapes[Math.floor(Math.random() * CONFIG.colors.shapes.length)];
                shapes.push({ matrix, color, used: false });
                const wrapper = document.createElement('div');
                wrapper.className = 'shape-preview';
                const canvasEl = document.createElement('canvas');
                canvasEl.className = 'shape-item';
                canvasEl.dataset.index = i; 
                drawShapeToCanvas(canvasEl, matrix, color, 0.55); 
                wrapper.appendChild(canvasEl);
                shapesContainer.appendChild(wrapper);
            }
            checkGameOver();
        }

        function canPlace(matrix, r, c) {
            for(let i=0; i<matrix.length; i++) {
                for(let j=0; j<matrix[0].length; j++) {
                    if(matrix[i][j] === 1) {
                        const tr = r + i;
                        const tc = c + j;
                        if(tr < 0 || tr >= CONFIG.gridSize || tc < 0 || tc >= CONFIG.gridSize || grid[tr][tc]) return false;
                    }
                }
            }
            return true;
        }

        function placeShape(shape, r, c) {
            let placedCount = 0;
            for(let i=0; i<shape.matrix.length; i++) {
                for(let j=0; j<shape.matrix[0].length; j++) {
                    if(shape.matrix[i][j] === 1) {
                        grid[r + i][c + j] = shape.color;
                        placedCount++;
                    }
                }
            }
            score += placedCount;
            updateScore(score);
            requestAnimationFrame(() => { checkLines(); drawGrid(); });
        }

        function checkLines() {
            let rowsToClear = [], colsToClear = [];
            for(let r=0; r<CONFIG.gridSize; r++) if(grid[r].every(v => v)) rowsToClear.push(r);
            for(let c=0; c<CONFIG.gridSize; c++) if(grid.every(row => row[c])) colsToClear.push(c);
            if(rowsToClear.length === 0 && colsToClear.length === 0) return;
            rowsToClear.forEach(r => grid[r].fill(null));
            colsToClear.forEach(c => { for(let r=0; r<CONFIG.gridSize; r++) grid[r][c] = null; });
            const lines = rowsToClear.length + colsToClear.length;
            const points = lines * 100 * lines; 
            updateScore(score + points);
        }

        function checkGameOver() {
            const remaining = shapes.filter(s => !s.used);
            if(remaining.length === 0) return;
            let canMove = false;
            for(let s of remaining) {
                for(let r=0; r<CONFIG.gridSize; r++) {
                    for(let c=0; c<CONFIG.gridSize; c++) {
                        if(canPlace(s.matrix, r, c)) { canMove = true; break; }
                    }
                    if(canMove) break;
                }
                if(canMove) break;
            }
            if(!canMove) {
                finalScoreEl.innerText = score;
                finalBestScoreEl.innerText = bestScore;
                modal.style.display = 'flex';
            }
        }

        function updateScore(v) {
            score = v;
            scoreEl.innerText = score;
            
            const level = Math.floor(score / 10000);
            const colorIndex = level % BG_GRADIENTS.length;
            appWrapper.style.background = BG_GRADIENTS[colorIndex];

            if(score > bestScore) {
                bestScore = score;
                bestEl.innerText = bestScore;
                localStorage.setItem('blockBlastBest', bestScore);
            }
        }

        init();
    </script>
</body>
</html>