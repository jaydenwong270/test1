<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Block Puzzle - Fixed</title>
    <style>
        :root {
            --bg-color: #556070;         
            --grid-bg: #2b3342;          
            --cell-empty: #3b4353;       
            --text-color: #ffffff;
            --accent-gold: #ffcc00;      
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none; /* ç¦æ­¢ç€è¦½å™¨é è¨­æ»‘å‹• */
        }

        /* é ‚éƒ¨ */
        .top-bar {
            width: 100%;
            max-width: 450px;
            display: flex;
            justify-content: space-between;
            padding: 20px;
        }

        .high-score { font-size: 1.2rem; color: var(--accent-gold); font-weight: bold; }
        .current-score { font-size: 3.5rem; font-weight: bold; margin: 0 0 20px 0; }

        /* éŠæˆ²å€åŸŸ */
        #game-board-container {
            position: relative;
            background: var(--grid-bg);
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        canvas#gridCanvas {
            display: block;
            border-radius: 6px;
        }

        /* åº•éƒ¨æ–¹å¡Šå€ */
        .shapes-area {
            margin-top: 40px;
            width: 100%;
            max-width: 450px;
            height: 120px;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .shape-preview {
            width: 30%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas.shape-item {
            transition: transform 0.1s, opacity 0.2s;
        }

        /* æ‹–æ›³ä»£ç† (è·Ÿéš¨æ‰‹æŒ‡) */
        #drag-proxy {
            position: fixed;
            pointer-events: none; /* è®“é»æ“Šç©¿é€ */
            z-index: 1000;
            opacity: 0.9;
            display: none;
            filter: drop-shadow(0 15px 15px rgba(0,0,0,0.4));
        }

        /* Game Over */
        #modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 2000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .btn-restart {
            background: #4ecdc4; color: #fff; border: none;
            padding: 15px 40px; font-size: 1.5rem; border-radius: 50px;
            font-weight: bold; cursor: pointer;
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="high-score">ğŸ‘‘ <span id="best-score">0</span></div>
        <div>âš™ï¸</div>
    </div>

    <div class="current-score" id="score">0</div>

    <div id="game-board-container">
        <canvas id="gridCanvas"></canvas>
    </div>

    <div class="shapes-area" id="shapes-container"></div>

    <canvas id="drag-proxy"></canvas>

    <div id="modal-overlay">
        <h2 style="font-size: 2rem; color: #ff6b6b; margin-bottom: 20px;">NO MOVES!</h2>
        <div style="font-size: 3rem; margin-bottom: 30px;" id="final-score">0</div>
        <button class="btn-restart" onclick="restartGame()">Try Again</button>
    </div>

    <script>
        // --- è¨­å®š ---
        const CONFIG = {
            gridSize: 8,
            gap: 3,         // æ ¼å­é–“è·
            borderRadius: 5,
            colors: {
                empty: '#3b4353',
                shapes: ['#ef476f', '#ffd166', '#06d6a0', '#118ab2', '#9d4edd', '#ff9f1c', '#3a86ff']
            }
        };

        // ç‚ºäº†è®“æ‰‹æŒ‡ä¸æ“‹ä½æ–¹å¡Šï¼Œæ‹–æ›³æ™‚æ–¹å¡Šæœƒå‘ä¸Šåç§»é€™äº›åƒç´ 
        const DRAG_OFFSET_Y = 80; 

        // --- è®Šæ•¸ ---
        let grid = []; 
        let score = 0;
        let bestScore = localStorage.getItem('blockBlastBest') || 0;
        let shapes = [];
        let cellSize = 0; // å‹•æ…‹è¨ˆç®—

        // æ‹–æ›³ç‹€æ…‹
        let isDragging = false;
        let dragShapeIndex = -1;
        let dragStartOffset = { x: 0, y: 0 }; // æŠ“å–é»ç›¸å°æ–¼æ–¹å¡Šä¸­å¿ƒçš„åç§»

        // DOM
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const proxyCanvas = document.getElementById('drag-proxy');
        const shapesContainer = document.getElementById('shapes-container');
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best-score');
        const modal = document.getElementById('modal-overlay');

        // å½¢ç‹€è³‡æ–™åº«
        const SHAPES_DB = [
            [[1]], [[1,1]], [[1],[1]], [[1,1,1]], [[1],[1],[1]], 
            [[1,1],[1,1]], // O
            [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], // L
            [[0,1],[0,1],[1,1]], [[1,1,1],[0,0,1]], // J
            [[0,1,0],[1,1,1]], // T
            [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]] // Z / S
        ];

        // --- åˆå§‹åŒ– ---
        function init() {
            bestEl.innerText = bestScore;
            resizeGame();
            
            // ç›£è½è¦–çª—å¤§å°æ”¹è®Š
            window.addEventListener('resize', () => {
                resizeGame();
                drawGrid();
            });

            // ç¶å®šè¼¸å…¥äº‹ä»¶
            window.addEventListener('mousedown', handleStart);
            window.addEventListener('touchstart', handleStart, {passive: false});
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('touchmove', handleMove, {passive: false});
            window.addEventListener('mouseup', handleEnd);
            window.addEventListener('touchend', handleEnd);

            restartGame();
        }

        function resizeGame() {
            // RWD: æ ¹æ“šè¢å¹•å¯¬åº¦è¨ˆç®— Canvas å¤§å°
            const maxWidth = Math.min(window.innerWidth - 40, 400); 
            // é€™è£¡è¨­å®š Canvas çš„å…§éƒ¨è§£æåº¦
            canvas.width = maxWidth;
            canvas.height = maxWidth;
            
            // åæ¨æ¯å€‹æ ¼å­çš„å¤§å°
            // Width = (Cell * 8) + (Gap * 9)
            cellSize = (canvas.width - (CONFIG.gap * (CONFIG.gridSize + 1))) / CONFIG.gridSize;
        }

        function restartGame() {
            grid = Array(CONFIG.gridSize).fill().map(() => Array(CONFIG.gridSize).fill(null));
            score = 0;
            updateScore(0);
            modal.style.display = 'none';
            drawGrid();
            spawnShapes();
        }

        // --- ç¹ªåœ– ---
        function drawRoundedRect(ctx, x, y, size, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.roundRect(x, y, size, size, r);
            ctx.fill();
        }

        function drawGrid(highlightMatrix = null, highlightRow = -1, highlightCol = -1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for(let r=0; r<CONFIG.gridSize; r++) {
                for(let c=0; c<CONFIG.gridSize; c++) {
                    const x = CONFIG.gap + c * (cellSize + CONFIG.gap);
                    const y = CONFIG.gap + r * (cellSize + CONFIG.gap);
                    
                    let color = grid[r][c] || CONFIG.colors.empty;

                    // ç¹ªè£½åŠé€æ˜é è¦½
                    if(highlightMatrix && highlightRow !== -1) {
                        const hr = r - highlightRow;
                        const hc = c - highlightCol;
                        if(hr >= 0 && hr < highlightMatrix.length &&
                           hc >= 0 && hc < highlightMatrix[0].length &&
                           highlightMatrix[hr][hc] === 1) {
                            
                            // å…ˆç•«åº•è‰²
                            drawRoundedRect(ctx, x, y, cellSize, CONFIG.borderRadius, CONFIG.colors.empty);
                            // å†ç–ŠåŠ åŠé€æ˜é è¦½è‰²
                            ctx.globalAlpha = 0.5;
                            drawRoundedRect(ctx, x, y, cellSize, CONFIG.borderRadius, shapes[dragShapeIndex].color);
                            ctx.globalAlpha = 1.0;
                            continue;
                        }
                    }
                    drawRoundedRect(ctx, x, y, cellSize, CONFIG.borderRadius, color);
                }
            }
        }

        function drawShapeToCanvas(targetCanvas, matrix, color, scale = 1) {
            const size = cellSize * scale;
            const gap = CONFIG.gap * scale;
            const rows = matrix.length;
            const cols = matrix[0].length;
            
            targetCanvas.width = gap + cols * (size + gap);
            targetCanvas.height = gap + rows * (size + gap);
            
            const tCtx = targetCanvas.getContext('2d');
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(matrix[r][c]) {
                        drawRoundedRect(tCtx, 
                            gap + c * (size + gap), 
                            gap + r * (size + gap), 
                            size, CONFIG.borderRadius * scale, color);
                    }
                }
            }
        }

        // --- æ ¸å¿ƒä¿®å¾©ï¼šè¼¸å…¥è™•ç† ---
        
        function getEventPos(e) {
            if(e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.changedTouches && e.changedTouches.length > 0) { // ç”¨æ–¼ touchend
                return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function handleStart(e) {
            // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°åº•éƒ¨çš„å€™é¸æ–¹å¡Š
            const target = e.target.closest('.shape-item');
            if(!target) return;
            
            const index = parseInt(target.dataset.index);
            if(shapes[index].used) return;

            e.preventDefault();
            isDragging = true;
            dragShapeIndex = index;

            const pos = getEventPos(e);
            const shape = shapes[index];

            // ç¹ªè£½ 1:1 å¤§å°çš„æ‹–æ›³ä»£ç†
            drawShapeToCanvas(proxyCanvas, shape.matrix, shape.color, 1.0);
            proxyCanvas.style.display = 'block';

            // è¨­å®šåˆå§‹ä½ç½® (è®“æ–¹å¡Šä¸­å¿ƒå°é½Šæ‰‹æŒ‡)
            const rect = proxyCanvas.getBoundingClientRect(); // å–å¾—å‰›ç•«å¥½çš„å¤§å°
            dragStartOffset.x = rect.width / 2;
            dragStartOffset.y = rect.height / 2;
            
            updateProxyPos(pos.x, pos.y);

            // éš±è—åŸæœ¬åº•éƒ¨çš„æ–¹å¡Š
            target.style.opacity = 0;
        }

        function handleMove(e) {
            if(!isDragging) return;
            e.preventDefault(); // é˜²æ­¢æ‰‹æ©Ÿæ»¾å‹•
            const pos = getEventPos(e);
            updateProxyPos(pos.x, pos.y);

            // åˆ¤å®šç¶²æ ¼ä½ç½®
            const gridPos = getGridPosFromProxy();
            
            if(gridPos && canPlace(shapes[dragShapeIndex].matrix, gridPos.r, gridPos.c)) {
                drawGrid(shapes[dragShapeIndex].matrix, gridPos.r, gridPos.c);
            } else {
                drawGrid();
            }
        }

        function handleEnd(e) {
            if(!isDragging) return;
            
            const gridPos = getGridPosFromProxy();
            const shape = shapes[dragShapeIndex];
            const originalEl = document.querySelector(`.shape-item[data-index="${dragShapeIndex}"]`);

            if(gridPos && canPlace(shape.matrix, gridPos.r, gridPos.c)) {
                // æ”¾ç½®æˆåŠŸ
                placeShape(shape, gridPos.r, gridPos.c);
                shape.used = true;
                originalEl.parentElement.innerHTML = ''; // ç§»é™¤åº•éƒ¨é¡¯ç¤º
                
                if(shapes.every(s => s.used)) spawnShapes();
                else checkGameOver();
            } else {
                // æ”¾ç½®å¤±æ•—ï¼Œå½ˆå›
                originalEl.style.opacity = 1;
                drawGrid();
            }

            isDragging = false;
            proxyCanvas.style.display = 'none';
        }

        function updateProxyPos(x, y) {
            // æ–¹å¡Šè·Ÿéš¨æ‰‹æŒ‡ï¼Œä¸¦å‘ä¸Šåç§» DRAG_OFFSET_Y
            proxyCanvas.style.left = (x - dragStartOffset.x) + 'px';
            proxyCanvas.style.top = (y - dragStartOffset.y - DRAG_OFFSET_Y) + 'px';
        }

        // --- é—œéµä¿®å¾©ï¼šåº§æ¨™æ›ç®— ---
        function getGridPosFromProxy() {
            // å–å¾—ç›®å‰æ‹–æ›³æ–¹å¡Š(Proxy)åœ¨è¢å¹•ä¸Šçš„ä½ç½®
            const proxyRect = proxyCanvas.getBoundingClientRect();
            const gridRect = canvas.getBoundingClientRect();

            // è¨ˆç®— Proxy å·¦ä¸Šè§’ç›¸å°æ–¼ Grid å·¦ä¸Šè§’çš„è·é›¢ (åƒç´ )
            // é€™è£¡ä¸éœ€è¦è€ƒæ…® DRAG_OFFSET_Yï¼Œå› ç‚º proxyRect å·²ç¶“æ˜¯è¦–è¦ºä¸Šçš„å¯¦éš›ä½ç½®
            const relativeX = proxyRect.left - gridRect.left;
            const relativeY = proxyRect.top - gridRect.top;

            // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ (è§£æ±º CSS å¯¬åº¦èˆ‡ Canvas è§£æåº¦ä¸ä¸€è‡´çš„å•é¡Œ)
            const scaleX = canvas.width / gridRect.width;
            const scaleY = canvas.height / gridRect.height;

            // æ›ç®—å› Canvas å…§éƒ¨çš„åƒç´ åº§æ¨™
            const canvasX = relativeX * scaleX;
            const canvasY = relativeY * scaleY;

            // æ›ç®—æˆæ ¼å­åº§æ¨™ (ä½¿ç”¨ round ä¾†å®¹è¨±èª¤å·®ï¼Œè®“æ“ä½œæ›´é †æ‰‹)
            const col = Math.round((canvasX - CONFIG.gap) / (cellSize + CONFIG.gap));
            const row = Math.round((canvasY - CONFIG.gap) / (cellSize + CONFIG.gap));

            return { r: row, c: col };
        }

        // --- éŠæˆ²é‚è¼¯ ---
        function spawnShapes() {
            shapes = [];
            shapesContainer.innerHTML = '';
            for(let i=0; i<3; i++) {
                const matrix = SHAPES_DB[Math.floor(Math.random() * SHAPES_DB.length)];
                const color = CONFIG.colors.shapes[Math.floor(Math.random() * CONFIG.colors.shapes.length)];
                shapes.push({ matrix, color, used: false });

                const wrapper = document.createElement('div');
                wrapper.className = 'shape-preview';
                
                const canvasEl = document.createElement('canvas');
                canvasEl.className = 'shape-item';
                canvasEl.dataset.index = i; // æ¨™è¨˜ç´¢å¼•æ–¹ä¾¿æŸ¥æ‰¾
                drawShapeToCanvas(canvasEl, matrix, color, 0.6); // é è¦½ç¸®å°

                wrapper.appendChild(canvasEl);
                shapesContainer.appendChild(wrapper);
            }
            checkGameOver();
        }

        function canPlace(matrix, r, c) {
            for(let i=0; i<matrix.length; i++) {
                for(let j=0; j<matrix[0].length; j++) {
                    if(matrix[i][j] === 1) {
                        const tr = r + i;
                        const tc = c + j;
                        // é‚Šç•Œèˆ‡ç¢°æ’æª¢æŸ¥
                        if(tr < 0 || tr >= CONFIG.gridSize || tc < 0 || tc >= CONFIG.gridSize || grid[tr][tc]) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function placeShape(shape, r, c) {
            let placedCount = 0;
            for(let i=0; i<shape.matrix.length; i++) {
                for(let j=0; j<shape.matrix[0].length; j++) {
                    if(shape.matrix[i][j] === 1) {
                        grid[r + i][c + j] = shape.color;
                        placedCount++;
                    }
                }
            }
            score += placedCount;
            updateScore(score);
            
            // å»¶é²ä¸€é»é»æª¢æŸ¥æ¶ˆé™¤ï¼Œè®“ç©å®¶çœ‹åˆ°æ”¾ç½®ç¬é–“
            requestAnimationFrame(() => {
                checkLines();
                drawGrid();
            });
        }

        function checkLines() {
            let rowsToClear = [], colsToClear = [];
            
            // æª¢æŸ¥æ©«åˆ—
            for(let r=0; r<CONFIG.gridSize; r++) {
                if(grid[r].every(v => v)) rowsToClear.push(r);
            }
            // æª¢æŸ¥ç›´è¡Œ
            for(let c=0; c<CONFIG.gridSize; c++) {
                if(grid.every(row => row[c])) colsToClear.push(c);
            }

            if(rowsToClear.length === 0 && colsToClear.length === 0) return;

            // æ¶ˆé™¤
            rowsToClear.forEach(r => grid[r].fill(null));
            colsToClear.forEach(c => {
                for(let r=0; r<CONFIG.gridSize; r++) grid[r][c] = null;
            });

            // ç°¡å–®è¨ˆåˆ†
            const lines = rowsToClear.length + colsToClear.length;
            const points = lines * 100 * lines; // Combo åŠ æˆ
            updateScore(score + points);
        }

        function checkGameOver() {
            const remaining = shapes.filter(s => !s.used);
            if(remaining.length === 0) return;

            let canMove = false;
            for(let s of remaining) {
                for(let r=0; r<CONFIG.gridSize; r++) {
                    for(let c=0; c<CONFIG.gridSize; c++) {
                        if(canPlace(s.matrix, r, c)) {
                            canMove = true;
                            break;
                        }
                    }
                    if(canMove) break;
                }
                if(canMove) break;
            }

            if(!canMove) {
                document.getElementById('final-score').innerText = score;
                modal.style.display = 'flex';
            }
        }

        function updateScore(v) {
            score = v;
            scoreEl.innerText = score;
            if(score > bestScore) {
                bestScore = score;
                bestEl.innerText = bestScore;
                localStorage.setItem('blockBlastBest', bestScore);
            }
        }

        // å•Ÿå‹•
        init();

    </script>
</body>
</html>