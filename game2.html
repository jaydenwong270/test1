<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Plane - NYC Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
        }
        
        body {
            background-color: #2c3e50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            color: #ecf0f1;
        }

        .main-layout {
            display: flex;
            gap: 30px;
            max-width: 960px;
            width: 100%;
            background-color: #34495e;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.5);
            border: 4px solid #fff;
        }

        .game-section {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .panel-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        header { text-align: center; margin-bottom: 20px; width: 100%; }
        
        h1 {
            color: #e74c3c;
            font-size: 3.5rem;
            margin-bottom: 5px;
            text-shadow: 4px 4px 0 #fff, 8px 8px 0 #000;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        .subtitle {
            color: #bdc3c7;
            font-size: 1.2rem;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        
        .game-container {
            position: relative;
            width: 480px; 
            border: 4px solid #000;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            background-color: #87CEEB;
        }
        
        #gameCanvas {
            display: block;
            position: relative; 
            z-index: 0;
            image-rendering: pixelated;
        }
        
        .score-container {
            position: absolute;
            top: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            z-index: 10;
            pointer-events: none;
        }
        
        .score-box {
            background-color: rgba(255, 255, 255, 0.8);
            border: 3px solid #000;
            color: #2c3e50;
            padding: 10px 30px;
            font-size: 4rem;
            font-weight: 800;
            text-align: center;
            box-shadow: 5px 5px 0 #000;
        }
        
        .high-score-box {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 10;
        }
        
        .high-score {
            background-color: #2c3e50;
            border: 2px solid #fff;
            color: #f1c40f;
            padding: 8px 15px;
            font-size: 1.1rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 3px 3px 0 rgba(0,0,0,0.5);
        }

        .panel-box {
            background-color: #2c3e50;
            border: 3px solid #fff;
            padding: 20px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        
        .panel-title {
            color: #fff;
            font-size: 1.3rem;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
            text-decoration: underline;
            text-decoration-color: #e74c3c;
            text-transform: uppercase;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        
        .control-item {
            display: flex;
            align-items: center;
            gap: 15px;
            background-color: #34495e;
            padding: 10px;
            border: 2px solid #000;
        }
        
        .key {
            background-color: #e74c3c;
            color: #fff;
            padding: 5px 10px;
            font-weight: bold;
            min-width: 60px;
            text-align: center;
            font-size: 0.9rem;
            box-shadow: 3px 3px 0 #000;
            border: 2px solid #000;
        }
        
        .control-desc {
            color: #ecf0f1;
            font-size: 0.95rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .game-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: auto; 
        }
        
        button {
            background-color: #3498db;
            color: #fff;
            border: 3px solid #000;
            padding: 15px 20px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.1s ease;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 5px 5px 0 #000;
            width: 100%;
            text-transform: uppercase;
        }
        
        button:hover {
            background-color: #2980b9;
            transform: translate(2px, 2px);
            box-shadow: 3px 3px 0 #000;
        }
        
        button:active {
            transform: translate(5px, 5px);
            box-shadow: 0px 0px 0 #000;
        }
        
        button#startBtn { background-color: #e74c3c; }
        button#startBtn:hover { background-color: #c0392b; }
        button#pauseBtn { background-color: #f1c40f; color: #000; }
        button#resetBtn { background-color: #fff; color: #2c3e50; }
        button#resetBtn:hover { background-color: #bdc3c7; }
        
        .game-status {
            text-align: center;
            font-size: 1.1rem;
            font-weight: bold;
            color: #f1c40f;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 2px 2px 0 #000;
        }
        
        .game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; display: none; 
        }

        .game-over-box {
            background-color: #fff;
            border: 4px solid #000;
            padding: 25px;
            text-align: center;
            box-shadow: 10px 10px 0 #000;
            width: 85%;
        }

        .game-over-box h2 {
            color: #e74c3c;
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #000;
            text-transform: uppercase;
        }

        .score-result {
            background-color: #ecf0f1;
            padding: 15px;
            margin-bottom: 20px;
            border: 3px solid #000;
            box-shadow: inset 3px 3px 0 rgba(0,0,0,0.1);
        }

        .score-result div {
            font-size: 1.2rem;
            color: #2c3e50;
            margin: 10px 0;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }

        .score-result span { color: #e74c3c; font-size: 1.5rem; text-shadow: 1px 1px 0 #000; }

        @media (max-width: 900px) {
            .main-layout { flex-direction: column; align-items: center; padding: 15px; gap: 20px; }
            .game-section, .panel-section { flex: auto; width: 100%; max-width: 480px; }
            .game-container { width: 100%; height: auto; aspect-ratio: 3/4; }
            #gameCanvas { width: 100%; height: 100%; }
            h1 { font-size: 2.5rem; }
        }

    </style>
</head>
<body>
    <header>
        <h1>Flappy Plane</h1>
        <div class="subtitle">NYC 757 EDITION</div>
    </header>

    <div class="main-layout">
        <section class="game-section">
            <div class="game-container">
                <canvas id="gameCanvas" width="480" height="640"></canvas>
                <div class="score-container"><div class="score-box" id="scoreBox">0</div></div>
                <div class="high-score-box"><div class="high-score" id="highScoreBox">üëë 0</div></div>
                <div id="gameOverScreen" class="game-over-screen">
                    <div class="game-over-box">
                        <h2>CRASHED!</h2>
                        <div class="score-result">
                            <div>SCORE <span id="finalScore">0</span></div>
                            <div>BEST <span id="finalHighScore">0</span></div>
                        </div>
                        <button id="overlayRestartBtn">TRY AGAIN</button>
                    </div>
                </div>
            </div>
        </section>

        <section class="panel-section">
            <div class="panel-box">
                <div class="panel-title">FLIGHT STATUS</div>
                <div class="game-status" id="gameStatus">PRESS SPACE TO TAKE OFF</div>
            </div>
            <div class="panel-box">
                <div class="panel-title">CONTROLS</div>
                <div class="controls">
                    <div class="control-item"><div class="key">SPACE</div><div class="control-desc">FLY UP / START</div></div>
                    <div class="control-item"><div class="key">TAP</div><div class="control-desc">SCREEN TO FLY</div></div>
                    <div class="control-item"><div class="key">P</div><div class="control-desc">PAUSE</div></div>
                    <div class="control-item"><div class="key">R</div><div class="control-desc">RESET</div></div>
                </div>
            </div>
            <div class="game-controls">
                <button id="startBtn">START FLIGHT</button>
                <button id="pauseBtn">PAUSE</button>
                <button id="resetBtn">RESET</button>
            </div>
        </section>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        let gameRunning = false, gamePaused = false, score = 0, highScore = 0, frames = 0, gameSpeed = 3; 

        const gameOverScreen = document.getElementById('gameOverScreen'), finalScoreEl = document.getElementById('finalScore'), finalHighScoreEl = document.getElementById('finalHighScore'), overlayRestartBtn = document.getElementById('overlayRestartBtn'), gameStatusElement = document.getElementById('gameStatus'), startBtn = document.getElementById('startBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn'), highScoreBox = document.getElementById('highScoreBox');

        function loadHighScore() {
            const saved = localStorage.getItem('flappyPlaneHighScore');
            if (saved) { highScore = parseInt(saved); highScoreBox.textContent = `üëë ${highScore}`; }
        }
        function saveHighScore() {
            if (score > highScore) { highScore = score; localStorage.setItem('flappyPlaneHighScore', highScore); highScoreBox.textContent = `üëë ${highScore}`; }
        }
        
        function drawPixelRect(x, y, w, h, fill, border = '#000', borderThickness = 3) {
            ctx.fillStyle = border; ctx.fillRect(x, y, w, h);
            ctx.fillStyle = fill; ctx.fillRect(x + borderThickness, y + borderThickness, w - borderThickness*2, h - borderThickness*2);
        }

        // --- 1. Âú∞Èù¢ËàáÁ∏ÆÂ∞èÁöÑÁæéÂúãÂú∞Ê®ô ---
        const ground = {
            height: 80, // Âú∞Èù¢È´òÂ∫¶Èôç‰Ωé
            groundColor: '#7f8c8d', stripeColor: '#f1c40f', offset: 0, 
            
            // Âú∞Ê®ô (Â∞∫ÂØ∏Ê∏õÂçäÔºåÈ°èËâ≤Ë™øÊ∑°Ôºå‰ΩúÁÇ∫ÈÅ†ÊôØ)
            landmarks: [
                { name: 'Liberty', w: 40, h: 100, color: '#a2d9ce' }, 
                { name: 'Empire', w: 35, h: 140, color: '#b2babb' },
                { name: 'Brooklyn', w: 100, h: 60, color: '#95a5a6' },
                { name: 'Chrysler', w: 30, h: 130, color: '#d5dbdb' },
                { name: 'WhiteHouse', w: 60, h: 40, color: '#ecf0f1' },
                { name: 'Capitol', w: 70, h: 70, color: '#ecf0f1' },
                { name: 'GoldenGate', w: 110, h: 90, color: '#e6b0aa' }, // Ê∑°Á¥Ö
                { name: 'Needle', w: 25, h: 120, color: '#ecf0f1' }
            ],

            draw: function() {
                let gTop = canvas.height - this.height;
                
                // ÂÖàÁï´ËÉåÊôØÂú∞Ê®ô (Á¢∫‰øùÂú®Âú∞Èù¢Â∫ï‰∏ã)
                this.drawLandmarks(this.offset * 0.3); // ÈÄüÂ∫¶ËºÉÊÖ¢ÔºåÁî¢ÁîüË∑ùÈõ¢ÊÑü

                // Áï´Ê∞¥Ê≥•Âú∞Èù¢
                ctx.fillStyle = this.groundColor; ctx.fillRect(0, gTop, canvas.width, this.height);
                // Áï´ÈÅìË∑ØËôõÁ∑ö
                ctx.fillStyle = this.stripeColor;
                for(let i=0; i<canvas.width; i+=80) {
                     let drawX = (i - this.offset) % canvas.width; if(drawX < 0) drawX += canvas.width;
                     ctx.fillRect(drawX, gTop + 30, 40, 6);
                }
                ctx.fillStyle = '#000'; ctx.fillRect(0, gTop, canvas.width, 3);
            },

            drawLandmarks(offset) {
                let gTop = canvas.height - this.height;
                let totalWidth = this.landmarks.reduce((sum, lm) => sum + lm.w + 60, 0); 
                let baseX = offset % totalWidth; if (baseX > 0) baseX -= totalWidth;

                for(let i=0; i<2; i++) { 
                    let currentX = baseX + i * totalWidth;
                    this.landmarks.forEach(lm => {
                        let x = currentX; let y = gTop - lm.h;
                        // Ê∑°Ëâ≤ÈÇäÊ°ÜÔºå‰∏çË¶ÅÂ§™Êê∂Áúº
                        let borderColor = 'rgba(0,0,0,0.3)'; 
                        
                        if(lm.name === 'Liberty') {
                            drawPixelRect(x+10, y+40, 20, 60, lm.color, borderColor, 1);
                            drawPixelRect(x+15, y, 10, 40, lm.color, borderColor, 1);
                            ctx.fillStyle = '#f39c12'; ctx.fillRect(x+28, y-10, 5, 10); // ÁÅ´ÁÇ¨
                        } else if (lm.name === 'Empire') {
                            drawPixelRect(x, y+20, lm.w, lm.h-20, lm.color, borderColor, 1);
                            drawPixelRect(x+10, y, 15, 20, lm.color, borderColor, 1);
                            drawPixelRect(x+16, y-15, 3, 15, '#7f8c8d', borderColor, 1);
                        } else if (lm.name === 'Brooklyn') {
                             drawPixelRect(x, y, 20, lm.h, '#95a5a6', borderColor, 1);
                             drawPixelRect(x+lm.w-20, y, 20, lm.h, '#95a5a6', borderColor, 1);
                             ctx.strokeStyle = '#555'; ctx.lineWidth = 1;
                             ctx.beginPath(); ctx.moveTo(x+20, y+10); ctx.lineTo(x+lm.w/2, y+40); ctx.lineTo(x+lm.w-20, y+10); ctx.stroke();
                             ctx.fillRect(x, y+40, lm.w, 5);
                        } else if (lm.name === 'GoldenGate') {
                             drawPixelRect(x, y, 15, lm.h, lm.color, borderColor, 1); 
                             drawPixelRect(x+lm.w-15, y, 15, lm.h, lm.color, borderColor, 1);
                             ctx.strokeStyle = lm.color; ctx.lineWidth = 2;
                             ctx.beginPath(); ctx.moveTo(x+15, y+5); ctx.quadraticCurveTo(x+lm.w/2, y+50, x+lm.w-15, y+5); ctx.stroke();
                        } else if (lm.name === 'WhiteHouse') {
                             drawPixelRect(x, y+15, lm.w, 25, lm.color, borderColor, 1);
                             drawPixelRect(x+20, y, 20, 15, lm.color, borderColor, 1);
                        } else if (lm.name === 'Capitol') {
                             drawPixelRect(x, y+30, lm.w, 40, lm.color, borderColor, 1);
                             ctx.beginPath(); ctx.arc(x+lm.w/2, y+30, 20, Math.PI, 0); ctx.fillStyle=lm.color; ctx.fill(); 
                             drawPixelRect(x+lm.w/2-2, y-5, 4, 10, '#000', borderColor, 1);
                        } else if (lm.name === 'Needle') {
                             drawPixelRect(x+10, y+20, 5, 100, lm.color, borderColor, 1);
                             drawPixelRect(x, y, 25, 10, lm.color, borderColor, 1);
                             drawPixelRect(x+11, y-15, 3, 15, '#000', borderColor, 1);
                        } else {
                            drawPixelRect(x, y, lm.w, lm.h, lm.color, borderColor, 1);
                        }
                        currentX += lm.w + 60;
                    });
                }
            },
            update() { this.offset += gameSpeed; }
        };

        // --- 2. Áèæ‰ª£ÂÆ¢Ê©ü (Ê≥¢Èü≥757 È¢®Ê†º) ---
        const bird = {
            x: 80, y: canvas.height / 3, width: 80, height: 24, // Ê©üË∫´Âä†Èï∑
            gravity: 0.5, velocity: 0, jumpPower: -7.5, rotation: 0,
            hitboxScale: 0.7, // Á∏ÆÂ∞èÁ¢∞ÊíûÊ°Ü‰ª•ÂåπÈÖçË¶ñË¶∫ÊïàÊûú
            debugMode: false, // ÂïüÁî®Á¢∞ÊíûÊ°ÜË¶ñË¶∫Âåñ
            
            draw: function() {
                ctx.save(); ctx.translate(this.x, this.y);
                if (this.velocity < 0) this.rotation = -20 * Math.PI / 180; else this.rotation += 2 * Math.PI / 180;
                if (this.rotation > 30 * Math.PI / 180) this.rotation = 30 * Math.PI / 180;
                ctx.rotate(this.rotation);

                let bx = -this.width/2; let by = -this.height/2;

                // Ê©üË∫´ (ÁôΩËâ≤ÁÇ∫‰∏ªÔºåÂ∏∂ËóçÊ¢ùÁ¥ã)
                // Ê©üÈ†≠ (ÂúìÊªë)
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(bx + this.width - 10, by + 12, 12, 10, 0, -Math.PI/2, Math.PI/2);
                ctx.fill();
                ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.stroke();

                // Ê©üË∫´‰∏ªÈ´î
                drawPixelRect(bx + 10, by + 2, this.width - 20, 20, '#fff', '#000', 2);
                
                // ËóçËâ≤Ê¢ùÁ¥ã
                ctx.fillStyle = '#3498db';
                ctx.fillRect(bx + 10, by + 10, this.width - 25, 4);

                // ÂûÇÁõ¥Â∞æÁøº
                ctx.beginPath();
                ctx.moveTo(bx + 10, by + 2);
                ctx.lineTo(bx, by + 2);
                ctx.lineTo(bx - 5, by - 15);
                ctx.lineTo(bx + 15, by - 15);
                ctx.closePath();
                ctx.fillStyle = '#3498db'; ctx.fill(); ctx.stroke();

                // Ê©üÁøº (‰ΩçÊñºÊ©üË∫´‰∏ãÊñπÔºåÂæåÊé†Áøº)
                ctx.beginPath();
                ctx.moveTo(bx + 40, by + 15);
                ctx.lineTo(bx + 20, by + 35);
                ctx.lineTo(bx + 35, by + 35);
                ctx.lineTo(bx + 55, by + 15);
                ctx.closePath();
                ctx.fillStyle = '#bdc3c7'; ctx.fill(); ctx.stroke();

                // ÂºïÊìé (ÊéõÂú®Ê©üÁøº‰∏ã)
                drawPixelRect(bx + 30, by + 20, 15, 8, '#7f8c8d', '#000', 1);

                // ÈßïÈßõËâôÁ™óÊà∂
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(bx + this.width - 18, by + 5, 8, 4);

                // Áπ™Ë£ΩÁ¢∞ÊíûÊ°Ü (Èô§ÈåØÁî®)
                if (this.debugMode) {
                    ctx.restore();
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(
                        -this.width * this.hitboxScale / 2,
                        -this.height * this.hitboxScale / 2,
                        this.width * this.hitboxScale,
                        this.height * this.hitboxScale
                    );
                    ctx.setLineDash([]);
                }

                ctx.restore();
            },
            
            // Ë®àÁÆóÊóãËΩâÂæåÁöÑÁ¢∞ÊíûÊ°ÜÈÇäÁïå
            getRotatedBounds: function() {
                const halfWidth = this.width * this.hitboxScale / 2;
                const halfHeight = this.height * this.hitboxScale / 2;
                
                // ÂõõÂÄãËßíÈªû (Êú™ÊóãËΩâ)
                const corners = [
                    { x: -halfWidth, y: -halfHeight },
                    { x: halfWidth, y: -halfHeight },
                    { x: halfWidth, y: halfHeight },
                    { x: -halfWidth, y: halfHeight }
                ];
                
                // ÊóãËΩâËßíÈªû
                const cos = Math.cos(this.rotation);
                const sin = Math.sin(this.rotation);
                
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                for (const corner of corners) {
                    const rotatedX = corner.x * cos - corner.y * sin + this.x;
                    const rotatedY = corner.x * sin + corner.y * cos + this.y;
                    
                    minX = Math.min(minX, rotatedX);
                    maxX = Math.max(maxX, rotatedX);
                    minY = Math.min(minY, rotatedY);
                    maxY = Math.max(maxY, rotatedY);
                }
                
                return {
                    left: minX,
                    right: maxX,
                    top: minY,
                    bottom: maxY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            },
            
            // Ê™¢Êü•ËàáÁü©ÂΩ¢ÁöÑÁ¢∞Êíû
            collidesWithRect: function(rectX, rectY, rectWidth, rectHeight) {
                const bounds = this.getRotatedBounds();
                
                // Ëª∏Â∞çÈΩäÈÇäÁïåÊ°ÜÁ¢∞ÊíûÊ™¢Ê∏¨
                return !(
                    bounds.right < rectX ||
                    bounds.left > rectX + rectWidth ||
                    bounds.bottom < rectY ||
                    bounds.top > rectY + rectHeight
                );
            },
            
            jump: function() { this.velocity = this.jumpPower; this.rotation = -20 * Math.PI / 180; },
            update: function() {
                this.velocity += this.gravity; this.y += this.velocity;
                
                // Âú∞Èù¢Á¢∞ÊíûÊ™¢Ê∏¨
                const groundY = canvas.height - ground.height;
                const bounds = this.getRotatedBounds();
                if (bounds.bottom >= groundY) {
                    this.y = groundY - (bounds.bottom - this.y) - 1;
                    if (gameRunning) gameOver();
                }
                
                // Â§©Ëä±ÊùøÁ¢∞ÊíûÊ™¢Ê∏¨
                if (bounds.top <= 0) {
                    this.y = (bounds.top - this.y) + 1;
                    this.velocity = Math.max(this.velocity, 0);
                }
            },
            reset: function() { this.y = canvas.height / 3; this.velocity = 0; this.rotation = 0; }
        };
        
        // --- 3. Ê∞¥ÁÆ° (‰øùÊåÅ‰∏ñË≤øÈõôÂ°îÔºåÈ´òÂ∞çÊØîÂ∫¶) ---
        const pipes = {
            position: [], width: 70, gap: 170, minTopPipeHeight: 80,
            pipeMargin: 5, // Ê∞¥ÁÆ°Á¢∞ÊíûÈÇäË∑ù
            
            draw: function() {
                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    this.drawTower(p.x, 0, this.width, p.top, true);
                    this.drawTower(p.x, p.top + this.gap, this.width, canvas.height - (p.top + this.gap) - ground.height, false);
                    
                    // Áπ™Ë£ΩÊ∞¥ÁÆ°Á¢∞ÊíûÊ°Ü (Èô§ÈåØÁî®)
                    if (bird.debugMode) {
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([3, 3]);
                        
                        // ‰∏äÊ∞¥ÁÆ°Á¢∞ÊíûÊ°Ü
                        ctx.strokeRect(
                            p.x + this.pipeMargin,
                            0 + this.pipeMargin,
                            this.width - this.pipeMargin * 2,
                            p.top - this.pipeMargin * 2
                        );
                        
                        // ‰∏ãÊ∞¥ÁÆ°Á¢∞ÊíûÊ°Ü
                        ctx.strokeRect(
                            p.x + this.pipeMargin,
                            p.top + this.gap + this.pipeMargin,
                            this.width - this.pipeMargin * 2,
                            canvas.height - (p.top + this.gap) - ground.height - this.pipeMargin * 2
                        );
                        
                        ctx.setLineDash([]);
                    }
                }
            },
            drawTower(x, y, w, h, isTop) {
                // Ê∑±ÁÅ∞Ëâ≤ÔºåÁ¢∫‰øùÊØîËÉåÊôØÈ°ØÁúº
                drawPixelRect(x, y, w, h, '#7f8c8d', '#000', 3);
                ctx.fillStyle = '#2c3e50'; // Á™óÊà∂Ê∑±Ëâ≤
                for(let lx = x + 10; lx < x + w; lx += 10) { ctx.fillRect(lx, y, 2, h); }
                let capY = isTop ? y + h - 10 : y;
                ctx.fillStyle = '#2c3e50'; ctx.fillRect(x, capY, w, 10);
            },
            update: function() {
                if (frames % 120 === 0) {
                    const availableHeight = canvas.height - ground.height;
                    const maxTop = availableHeight - this.gap - 80;
                    this.position.push({
                        x: canvas.width,
                        top: Math.floor(Math.random() * (maxTop - this.minTopPipeHeight + 1)) + this.minTopPipeHeight,
                        passed: false
                    });
                }
                
                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    p.x -= gameSpeed;
                    
                    // Ê™¢Êü•ÊòØÂê¶ÈÄöÈÅéÊ∞¥ÁÆ°
                    if (!p.passed && p.x + this.width < bird.x) {
                        p.passed = true;
                        score++;
                        document.getElementById('scoreBox').textContent = score;
                    }
                    
                    // ‰ΩøÁî®Êñ∞ÁöÑÁ¢∞ÊíûÊ™¢Ê∏¨ÊñπÊ≥ï
                    const topPipeRect = {
                        x: p.x + this.pipeMargin,
                        y: 0 + this.pipeMargin,
                        width: this.width - this.pipeMargin * 2,
                        height: p.top - this.pipeMargin * 2
                    };
                    
                    const bottomPipeRect = {
                        x: p.x + this.pipeMargin,
                        y: p.top + this.gap + this.pipeMargin,
                        width: this.width - this.pipeMargin * 2,
                        height: canvas.height - (p.top + this.gap) - ground.height - this.pipeMargin * 2
                    };
                    
                    // Ê™¢Êü•Ëàá‰∏ä‰∏ãÊ∞¥ÁÆ°ÁöÑÁ¢∞Êíû
                    if (bird.collidesWithRect(topPipeRect.x, topPipeRect.y, topPipeRect.width, topPipeRect.height) ||
                        bird.collidesWithRect(bottomPipeRect.x, bottomPipeRect.y, bottomPipeRect.width, bottomPipeRect.height)) {
                        gameOver();
                    }
                    
                    // ÁßªÈô§Ë∂ÖÂá∫Áï´Èù¢ÁöÑÊ∞¥ÁÆ°
                    if (p.x + this.width < 0) this.position.shift();
                }
            },
            reset: function() { this.position = []; }
        };
        
        // --- 4. ËÉåÊôØ ---
        const background = {
            cloudOffset: 0,
            draw: function() {
                let skyStep = 40;
                for(let y=0; y<canvas.height; y+=skyStep) {
                    let colorVal = Math.floor(map(y, 0, canvas.height, 255, 135));
                    ctx.fillStyle = `rgb(135, 206, ${colorVal})`; ctx.fillRect(0, y, canvas.width, skyStep);
                }
                this.cloudOffset -= 0.5;
                this.drawClouds(this.cloudOffset, 80, 1.0);
                this.drawClouds(this.cloudOffset - 250, 150, 0.7);
            },
            drawClouds(offset, yPos, scale) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                let baseX = offset % canvas.width; if (baseX > 0) baseX -= canvas.width;
                for(let i=0; i<2; i++) {
                    let x = baseX + i * canvas.width, s = 25 * scale;
                    drawPixelRect(x + 50, yPos, s*4, s, '#fff', 'transparent', 0);
                    drawPixelRect(x + 70, yPos - s, s*2, s, '#fff', 'transparent', 0);
                    drawPixelRect(x + 200, yPos + 50, s*3, s, '#fff', 'transparent', 0);
                }
            }
        };

        function map(value, start1, stop1, start2, stop2) { return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1)); }
        function gameOver() { gameRunning = false; gameStatusElement.textContent = "CRASHED!"; gameStatusElement.style.color = "#e74c3c"; saveHighScore(); finalScoreEl.textContent = score; finalHighScoreEl.textContent = highScore; gameOverScreen.style.display = 'flex'; }
        function draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); background.draw(); ground.draw(); pipes.draw(); bird.draw(); ctx.strokeStyle = '#000'; ctx.lineWidth = 8; ctx.strokeRect(0,0,canvas.width, canvas.height); }
        function update() { if (!gameRunning || gamePaused) return; frames++; bird.update(); pipes.update(); ground.update(); draw(); requestAnimationFrame(update); }
        function startGame() { if (gameRunning) return; gameOverScreen.style.display = 'none'; score = 0; frames = 0; document.getElementById('scoreBox').textContent = score; gameStatusElement.textContent = "FLYING!"; gameStatusElement.style.color = "#2ecc71"; bird.reset(); pipes.reset(); gameRunning = true; gamePaused = false; update(); }
        function pauseGame() { if (!gameRunning) return; gamePaused = !gamePaused; if (gamePaused) { gameStatusElement.textContent = "PAUSED"; gameStatusElement.style.color = "#f1c40f"; } else { gameStatusElement.textContent = "FLYING!"; gameStatusElement.style.color = "#2ecc71"; update(); } }
        function resetGame() { gameRunning = false; gamePaused = false; gameOverScreen.style.display = 'none'; score = 0; document.getElementById('scoreBox').textContent = score; gameStatusElement.textContent = "PRESS SPACE TO START"; gameStatusElement.style.color = "#f1c40f"; bird.reset(); pipes.reset(); background.cloudOffset = 0; ground.offset = 0; draw(); }
        document.addEventListener('keydown', (e) => {
            if (gameOverScreen.style.display === 'flex') {
                if (e.key === ' ' || e.key === 'Spacebar' || e.key === 'r' || e.key === 'R' || e.key === 'Enter') {
                    resetGame();
                    e.preventDefault();
                    return;
                }
            }
            switch (e.key) {
                case ' ': case 'Spacebar': case 'ArrowUp':
                    if (!gameRunning) startGame();
                    else if (!gamePaused) bird.jump();
                    e.preventDefault();
                    break;
                case 'p': case 'P':
                    pauseGame();
                    e.preventDefault();
                    break;
                case 'r': case 'R':
                    resetGame();
                    e.preventDefault();
                    break;
                case 'd': case 'D':
                    // ÂàáÊèõÈô§ÈåØÊ®°Âºè
                    bird.debugMode = !bird.debugMode;
                    gameStatusElement.textContent = bird.debugMode ? "DEBUG MODE ON" : "DEBUG MODE OFF";
                    gameStatusElement.style.color = bird.debugMode ? "#9b59b6" : "#f1c40f";
                    e.preventDefault();
                    break;
            }
        });
        canvas.addEventListener('click', () => { if (gameOverScreen.style.display === 'flex') return; if (!gameRunning) startGame(); else if (!gamePaused) bird.jump(); });
        startBtn.addEventListener('click', startGame); pauseBtn.addEventListener('click', pauseGame); resetBtn.addEventListener('click', resetGame); overlayRestartBtn.addEventListener('click', resetGame);
        loadHighScore(); background.draw(); ground.draw(); bird.draw();
    </script>
</body>
</html>